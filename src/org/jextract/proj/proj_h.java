// Generated by jextract

package org.jextract.proj;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class proj_h {

    proj_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("proj"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int PROJ_VERSION_MAJOR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PROJ_VERSION_MAJOR 8
     * }
     */
    public static int PROJ_VERSION_MAJOR() {
        return PROJ_VERSION_MAJOR;
    }
    private static final int PROJ_VERSION_MINOR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PROJ_VERSION_MINOR 2
     * }
     */
    public static int PROJ_VERSION_MINOR() {
        return PROJ_VERSION_MINOR;
    }
    private static final int PROJ_VERSION_PATCH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PROJ_VERSION_PATCH 1
     * }
     */
    public static int PROJ_VERSION_PATCH() {
        return PROJ_VERSION_PATCH;
    }
    private static final int PJ_DEFAULT_CTX = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PJ_DEFAULT_CTX 0
     * }
     */
    public static int PJ_DEFAULT_CTX() {
        return PJ_DEFAULT_CTX;
    }
    private static final int PROJ_ERR_INVALID_OP = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP 1024
     * }
     */
    public static int PROJ_ERR_INVALID_OP() {
        return PROJ_ERR_INVALID_OP;
    }
    private static final int PROJ_ERR_COORD_TRANSFM = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM 2048
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM() {
        return PROJ_ERR_COORD_TRANSFM;
    }
    private static final int PROJ_ERR_OTHER = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_OTHER 4096
     * }
     */
    public static int PROJ_ERR_OTHER() {
        return PROJ_ERR_OTHER;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = proj_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = proj_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = proj_h.C_INT;

    private static class pj_release$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, proj_h.C_CHAR);
        public static final MemorySegment SEGMENT = proj_h.findOrThrow("pj_release").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char pj_release[]
     * }
     */
    public static SequenceLayout pj_release$layout() {
        return pj_release$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char pj_release[]
     * }
     */
    public static long[] pj_release$dimensions() {
        return pj_release$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char pj_release[]
     * }
     */
    public static MemorySegment pj_release() {
        return pj_release$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char pj_release[]
     * }
     */
    public static void pj_release(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, pj_release$constants.SEGMENT, 0L, pj_release$constants.LAYOUT.byteSize());
    }
    private static final int PJ_LOG_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_NONE = 0
     * }
     */
    public static int PJ_LOG_NONE() {
        return PJ_LOG_NONE;
    }
    private static final int PJ_LOG_ERROR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_ERROR = 1
     * }
     */
    public static int PJ_LOG_ERROR() {
        return PJ_LOG_ERROR;
    }
    private static final int PJ_LOG_DEBUG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_DEBUG = 2
     * }
     */
    public static int PJ_LOG_DEBUG() {
        return PJ_LOG_DEBUG;
    }
    private static final int PJ_LOG_TRACE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_TRACE = 3
     * }
     */
    public static int PJ_LOG_TRACE() {
        return PJ_LOG_TRACE;
    }
    private static final int PJ_LOG_TELL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_TELL = 4
     * }
     */
    public static int PJ_LOG_TELL() {
        return PJ_LOG_TELL;
    }
    private static final int PJ_LOG_DEBUG_MAJOR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_DEBUG_MAJOR = 2
     * }
     */
    public static int PJ_LOG_DEBUG_MAJOR() {
        return PJ_LOG_DEBUG_MAJOR;
    }
    private static final int PJ_LOG_DEBUG_MINOR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PJ_LOG_LEVEL.PJ_LOG_DEBUG_MINOR = 3
     * }
     */
    public static int PJ_LOG_DEBUG_MINOR() {
        return PJ_LOG_DEBUG_MINOR;
    }

    private static class proj_context_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_create()
     * }
     */
    public static FunctionDescriptor proj_context_create$descriptor() {
        return proj_context_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_create()
     * }
     */
    public static MethodHandle proj_context_create$handle() {
        return proj_context_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_create()
     * }
     */
    public static MemorySegment proj_context_create$address() {
        return proj_context_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_create()
     * }
     */
    public static MemorySegment proj_context_create() {
        var mh$ = proj_context_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_destroy(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_destroy$descriptor() {
        return proj_context_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_destroy(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_destroy$handle() {
        return proj_context_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_destroy(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_destroy$address() {
        return proj_context_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_destroy(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_destroy(MemorySegment ctx) {
        var mh$ = proj_context_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_destroy", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_clone(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_clone$descriptor() {
        return proj_context_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_clone(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_clone$handle() {
        return proj_context_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_clone(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_clone$address() {
        return proj_context_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_CONTEXT *proj_context_clone(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_clone(MemorySegment ctx) {
        var mh$ = proj_context_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_clone", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_file_finder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_set_file_finder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_file_finder(PJ_CONTEXT *ctx, proj_file_finder finder, void *user_data)
     * }
     */
    public static FunctionDescriptor proj_context_set_file_finder$descriptor() {
        return proj_context_set_file_finder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_file_finder(PJ_CONTEXT *ctx, proj_file_finder finder, void *user_data)
     * }
     */
    public static MethodHandle proj_context_set_file_finder$handle() {
        return proj_context_set_file_finder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_file_finder(PJ_CONTEXT *ctx, proj_file_finder finder, void *user_data)
     * }
     */
    public static MemorySegment proj_context_set_file_finder$address() {
        return proj_context_set_file_finder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_file_finder(PJ_CONTEXT *ctx, proj_file_finder finder, void *user_data)
     * }
     */
    public static void proj_context_set_file_finder(MemorySegment ctx, MemorySegment finder, MemorySegment user_data) {
        var mh$ = proj_context_set_file_finder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_file_finder", ctx, finder, user_data);
            }
            mh$.invokeExact(ctx, finder, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_search_paths {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_set_search_paths");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_search_paths(PJ_CONTEXT *ctx, int count_paths, const char *const *paths)
     * }
     */
    public static FunctionDescriptor proj_context_set_search_paths$descriptor() {
        return proj_context_set_search_paths.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_search_paths(PJ_CONTEXT *ctx, int count_paths, const char *const *paths)
     * }
     */
    public static MethodHandle proj_context_set_search_paths$handle() {
        return proj_context_set_search_paths.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_search_paths(PJ_CONTEXT *ctx, int count_paths, const char *const *paths)
     * }
     */
    public static MemorySegment proj_context_set_search_paths$address() {
        return proj_context_set_search_paths.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_search_paths(PJ_CONTEXT *ctx, int count_paths, const char *const *paths)
     * }
     */
    public static void proj_context_set_search_paths(MemorySegment ctx, int count_paths, MemorySegment paths) {
        var mh$ = proj_context_set_search_paths.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_search_paths", ctx, count_paths, paths);
            }
            mh$.invokeExact(ctx, count_paths, paths);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_ca_bundle_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_set_ca_bundle_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_ca_bundle_path(PJ_CONTEXT *ctx, const char *path)
     * }
     */
    public static FunctionDescriptor proj_context_set_ca_bundle_path$descriptor() {
        return proj_context_set_ca_bundle_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_ca_bundle_path(PJ_CONTEXT *ctx, const char *path)
     * }
     */
    public static MethodHandle proj_context_set_ca_bundle_path$handle() {
        return proj_context_set_ca_bundle_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_ca_bundle_path(PJ_CONTEXT *ctx, const char *path)
     * }
     */
    public static MemorySegment proj_context_set_ca_bundle_path$address() {
        return proj_context_set_ca_bundle_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_ca_bundle_path(PJ_CONTEXT *ctx, const char *path)
     * }
     */
    public static void proj_context_set_ca_bundle_path(MemorySegment ctx, MemorySegment path) {
        var mh$ = proj_context_set_ca_bundle_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_ca_bundle_path", ctx, path);
            }
            mh$.invokeExact(ctx, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_use_proj4_init_rules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_use_proj4_init_rules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_use_proj4_init_rules(PJ_CONTEXT *ctx, int enable)
     * }
     */
    public static FunctionDescriptor proj_context_use_proj4_init_rules$descriptor() {
        return proj_context_use_proj4_init_rules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_use_proj4_init_rules(PJ_CONTEXT *ctx, int enable)
     * }
     */
    public static MethodHandle proj_context_use_proj4_init_rules$handle() {
        return proj_context_use_proj4_init_rules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_use_proj4_init_rules(PJ_CONTEXT *ctx, int enable)
     * }
     */
    public static MemorySegment proj_context_use_proj4_init_rules$address() {
        return proj_context_use_proj4_init_rules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_use_proj4_init_rules(PJ_CONTEXT *ctx, int enable)
     * }
     */
    public static void proj_context_use_proj4_init_rules(MemorySegment ctx, int enable) {
        var mh$ = proj_context_use_proj4_init_rules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_use_proj4_init_rules", ctx, enable);
            }
            mh$.invokeExact(ctx, enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_use_proj4_init_rules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_get_use_proj4_init_rules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_get_use_proj4_init_rules(PJ_CONTEXT *ctx, int from_legacy_code_path)
     * }
     */
    public static FunctionDescriptor proj_context_get_use_proj4_init_rules$descriptor() {
        return proj_context_get_use_proj4_init_rules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_get_use_proj4_init_rules(PJ_CONTEXT *ctx, int from_legacy_code_path)
     * }
     */
    public static MethodHandle proj_context_get_use_proj4_init_rules$handle() {
        return proj_context_get_use_proj4_init_rules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_get_use_proj4_init_rules(PJ_CONTEXT *ctx, int from_legacy_code_path)
     * }
     */
    public static MemorySegment proj_context_get_use_proj4_init_rules$address() {
        return proj_context_get_use_proj4_init_rules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_get_use_proj4_init_rules(PJ_CONTEXT *ctx, int from_legacy_code_path)
     * }
     */
    public static int proj_context_get_use_proj4_init_rules(MemorySegment ctx, int from_legacy_code_path) {
        var mh$ = proj_context_get_use_proj4_init_rules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_use_proj4_init_rules", ctx, from_legacy_code_path);
            }
            return (int)mh$.invokeExact(ctx, from_legacy_code_path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PROJ_OPEN_ACCESS_READ_ONLY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PROJ_OPEN_ACCESS.PROJ_OPEN_ACCESS_READ_ONLY = 0
     * }
     */
    public static int PROJ_OPEN_ACCESS_READ_ONLY() {
        return PROJ_OPEN_ACCESS_READ_ONLY;
    }
    private static final int PROJ_OPEN_ACCESS_READ_UPDATE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PROJ_OPEN_ACCESS.PROJ_OPEN_ACCESS_READ_UPDATE = 1
     * }
     */
    public static int PROJ_OPEN_ACCESS_READ_UPDATE() {
        return PROJ_OPEN_ACCESS_READ_UPDATE;
    }
    private static final int PROJ_OPEN_ACCESS_CREATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PROJ_OPEN_ACCESS.PROJ_OPEN_ACCESS_CREATE = 2
     * }
     */
    public static int PROJ_OPEN_ACCESS_CREATE() {
        return PROJ_OPEN_ACCESS_CREATE;
    }

    private static class proj_context_set_fileapi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_set_fileapi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_set_fileapi(PJ_CONTEXT *ctx, const PROJ_FILE_API *fileapi, void *user_data)
     * }
     */
    public static FunctionDescriptor proj_context_set_fileapi$descriptor() {
        return proj_context_set_fileapi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_set_fileapi(PJ_CONTEXT *ctx, const PROJ_FILE_API *fileapi, void *user_data)
     * }
     */
    public static MethodHandle proj_context_set_fileapi$handle() {
        return proj_context_set_fileapi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_set_fileapi(PJ_CONTEXT *ctx, const PROJ_FILE_API *fileapi, void *user_data)
     * }
     */
    public static MemorySegment proj_context_set_fileapi$address() {
        return proj_context_set_fileapi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_set_fileapi(PJ_CONTEXT *ctx, const PROJ_FILE_API *fileapi, void *user_data)
     * }
     */
    public static int proj_context_set_fileapi(MemorySegment ctx, MemorySegment fileapi, MemorySegment user_data) {
        var mh$ = proj_context_set_fileapi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_fileapi", ctx, fileapi, user_data);
            }
            return (int)mh$.invokeExact(ctx, fileapi, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_sqlite3_vfs_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_set_sqlite3_vfs_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_sqlite3_vfs_name(PJ_CONTEXT *ctx, const char *name)
     * }
     */
    public static FunctionDescriptor proj_context_set_sqlite3_vfs_name$descriptor() {
        return proj_context_set_sqlite3_vfs_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_sqlite3_vfs_name(PJ_CONTEXT *ctx, const char *name)
     * }
     */
    public static MethodHandle proj_context_set_sqlite3_vfs_name$handle() {
        return proj_context_set_sqlite3_vfs_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_sqlite3_vfs_name(PJ_CONTEXT *ctx, const char *name)
     * }
     */
    public static MemorySegment proj_context_set_sqlite3_vfs_name$address() {
        return proj_context_set_sqlite3_vfs_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_sqlite3_vfs_name(PJ_CONTEXT *ctx, const char *name)
     * }
     */
    public static void proj_context_set_sqlite3_vfs_name(MemorySegment ctx, MemorySegment name) {
        var mh$ = proj_context_set_sqlite3_vfs_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_sqlite3_vfs_name", ctx, name);
            }
            mh$.invokeExact(ctx, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_network_callbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_set_network_callbacks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_set_network_callbacks(PJ_CONTEXT *ctx, proj_network_open_cbk_type open_cbk, proj_network_close_cbk_type close_cbk, proj_network_get_header_value_cbk_type get_header_value_cbk, proj_network_read_range_type read_range_cbk, void *user_data)
     * }
     */
    public static FunctionDescriptor proj_context_set_network_callbacks$descriptor() {
        return proj_context_set_network_callbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_set_network_callbacks(PJ_CONTEXT *ctx, proj_network_open_cbk_type open_cbk, proj_network_close_cbk_type close_cbk, proj_network_get_header_value_cbk_type get_header_value_cbk, proj_network_read_range_type read_range_cbk, void *user_data)
     * }
     */
    public static MethodHandle proj_context_set_network_callbacks$handle() {
        return proj_context_set_network_callbacks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_set_network_callbacks(PJ_CONTEXT *ctx, proj_network_open_cbk_type open_cbk, proj_network_close_cbk_type close_cbk, proj_network_get_header_value_cbk_type get_header_value_cbk, proj_network_read_range_type read_range_cbk, void *user_data)
     * }
     */
    public static MemorySegment proj_context_set_network_callbacks$address() {
        return proj_context_set_network_callbacks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_set_network_callbacks(PJ_CONTEXT *ctx, proj_network_open_cbk_type open_cbk, proj_network_close_cbk_type close_cbk, proj_network_get_header_value_cbk_type get_header_value_cbk, proj_network_read_range_type read_range_cbk, void *user_data)
     * }
     */
    public static int proj_context_set_network_callbacks(MemorySegment ctx, MemorySegment open_cbk, MemorySegment close_cbk, MemorySegment get_header_value_cbk, MemorySegment read_range_cbk, MemorySegment user_data) {
        var mh$ = proj_context_set_network_callbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_network_callbacks", ctx, open_cbk, close_cbk, get_header_value_cbk, read_range_cbk, user_data);
            }
            return (int)mh$.invokeExact(ctx, open_cbk, close_cbk, get_header_value_cbk, read_range_cbk, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_enable_network {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_set_enable_network");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_set_enable_network(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static FunctionDescriptor proj_context_set_enable_network$descriptor() {
        return proj_context_set_enable_network.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_set_enable_network(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static MethodHandle proj_context_set_enable_network$handle() {
        return proj_context_set_enable_network.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_set_enable_network(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static MemorySegment proj_context_set_enable_network$address() {
        return proj_context_set_enable_network.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_set_enable_network(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static int proj_context_set_enable_network(MemorySegment ctx, int enabled) {
        var mh$ = proj_context_set_enable_network.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_enable_network", ctx, enabled);
            }
            return (int)mh$.invokeExact(ctx, enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_is_network_enabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_is_network_enabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_is_network_enabled(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_is_network_enabled$descriptor() {
        return proj_context_is_network_enabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_is_network_enabled(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_is_network_enabled$handle() {
        return proj_context_is_network_enabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_is_network_enabled(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_is_network_enabled$address() {
        return proj_context_is_network_enabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_is_network_enabled(PJ_CONTEXT *ctx)
     * }
     */
    public static int proj_context_is_network_enabled(MemorySegment ctx) {
        var mh$ = proj_context_is_network_enabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_is_network_enabled", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_url_endpoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_set_url_endpoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_url_endpoint(PJ_CONTEXT *ctx, const char *url)
     * }
     */
    public static FunctionDescriptor proj_context_set_url_endpoint$descriptor() {
        return proj_context_set_url_endpoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_url_endpoint(PJ_CONTEXT *ctx, const char *url)
     * }
     */
    public static MethodHandle proj_context_set_url_endpoint$handle() {
        return proj_context_set_url_endpoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_url_endpoint(PJ_CONTEXT *ctx, const char *url)
     * }
     */
    public static MemorySegment proj_context_set_url_endpoint$address() {
        return proj_context_set_url_endpoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_url_endpoint(PJ_CONTEXT *ctx, const char *url)
     * }
     */
    public static void proj_context_set_url_endpoint(MemorySegment ctx, MemorySegment url) {
        var mh$ = proj_context_set_url_endpoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_url_endpoint", ctx, url);
            }
            mh$.invokeExact(ctx, url);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_url_endpoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_get_url_endpoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_context_get_url_endpoint(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_get_url_endpoint$descriptor() {
        return proj_context_get_url_endpoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_context_get_url_endpoint(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_get_url_endpoint$handle() {
        return proj_context_get_url_endpoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_context_get_url_endpoint(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_get_url_endpoint$address() {
        return proj_context_get_url_endpoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_context_get_url_endpoint(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_get_url_endpoint(MemorySegment ctx) {
        var mh$ = proj_context_get_url_endpoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_url_endpoint", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_user_writable_directory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_get_user_writable_directory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_context_get_user_writable_directory(PJ_CONTEXT *ctx, int create)
     * }
     */
    public static FunctionDescriptor proj_context_get_user_writable_directory$descriptor() {
        return proj_context_get_user_writable_directory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_context_get_user_writable_directory(PJ_CONTEXT *ctx, int create)
     * }
     */
    public static MethodHandle proj_context_get_user_writable_directory$handle() {
        return proj_context_get_user_writable_directory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_context_get_user_writable_directory(PJ_CONTEXT *ctx, int create)
     * }
     */
    public static MemorySegment proj_context_get_user_writable_directory$address() {
        return proj_context_get_user_writable_directory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_context_get_user_writable_directory(PJ_CONTEXT *ctx, int create)
     * }
     */
    public static MemorySegment proj_context_get_user_writable_directory(MemorySegment ctx, int create) {
        var mh$ = proj_context_get_user_writable_directory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_user_writable_directory", ctx, create);
            }
            return (MemorySegment)mh$.invokeExact(ctx, create);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_cache_set_enable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_grid_cache_set_enable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_enable(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static FunctionDescriptor proj_grid_cache_set_enable$descriptor() {
        return proj_grid_cache_set_enable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_enable(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static MethodHandle proj_grid_cache_set_enable$handle() {
        return proj_grid_cache_set_enable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_enable(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static MemorySegment proj_grid_cache_set_enable$address() {
        return proj_grid_cache_set_enable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_grid_cache_set_enable(PJ_CONTEXT *ctx, int enabled)
     * }
     */
    public static void proj_grid_cache_set_enable(MemorySegment ctx, int enabled) {
        var mh$ = proj_grid_cache_set_enable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_cache_set_enable", ctx, enabled);
            }
            mh$.invokeExact(ctx, enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_cache_set_filename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_grid_cache_set_filename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_filename(PJ_CONTEXT *ctx, const char *fullname)
     * }
     */
    public static FunctionDescriptor proj_grid_cache_set_filename$descriptor() {
        return proj_grid_cache_set_filename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_filename(PJ_CONTEXT *ctx, const char *fullname)
     * }
     */
    public static MethodHandle proj_grid_cache_set_filename$handle() {
        return proj_grid_cache_set_filename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_filename(PJ_CONTEXT *ctx, const char *fullname)
     * }
     */
    public static MemorySegment proj_grid_cache_set_filename$address() {
        return proj_grid_cache_set_filename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_grid_cache_set_filename(PJ_CONTEXT *ctx, const char *fullname)
     * }
     */
    public static void proj_grid_cache_set_filename(MemorySegment ctx, MemorySegment fullname) {
        var mh$ = proj_grid_cache_set_filename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_cache_set_filename", ctx, fullname);
            }
            mh$.invokeExact(ctx, fullname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_cache_set_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_grid_cache_set_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_max_size(PJ_CONTEXT *ctx, int max_size_MB)
     * }
     */
    public static FunctionDescriptor proj_grid_cache_set_max_size$descriptor() {
        return proj_grid_cache_set_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_max_size(PJ_CONTEXT *ctx, int max_size_MB)
     * }
     */
    public static MethodHandle proj_grid_cache_set_max_size$handle() {
        return proj_grid_cache_set_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_max_size(PJ_CONTEXT *ctx, int max_size_MB)
     * }
     */
    public static MemorySegment proj_grid_cache_set_max_size$address() {
        return proj_grid_cache_set_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_grid_cache_set_max_size(PJ_CONTEXT *ctx, int max_size_MB)
     * }
     */
    public static void proj_grid_cache_set_max_size(MemorySegment ctx, int max_size_MB) {
        var mh$ = proj_grid_cache_set_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_cache_set_max_size", ctx, max_size_MB);
            }
            mh$.invokeExact(ctx, max_size_MB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_cache_set_ttl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_grid_cache_set_ttl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_ttl(PJ_CONTEXT *ctx, int ttl_seconds)
     * }
     */
    public static FunctionDescriptor proj_grid_cache_set_ttl$descriptor() {
        return proj_grid_cache_set_ttl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_ttl(PJ_CONTEXT *ctx, int ttl_seconds)
     * }
     */
    public static MethodHandle proj_grid_cache_set_ttl$handle() {
        return proj_grid_cache_set_ttl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_grid_cache_set_ttl(PJ_CONTEXT *ctx, int ttl_seconds)
     * }
     */
    public static MemorySegment proj_grid_cache_set_ttl$address() {
        return proj_grid_cache_set_ttl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_grid_cache_set_ttl(PJ_CONTEXT *ctx, int ttl_seconds)
     * }
     */
    public static void proj_grid_cache_set_ttl(MemorySegment ctx, int ttl_seconds) {
        var mh$ = proj_grid_cache_set_ttl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_cache_set_ttl", ctx, ttl_seconds);
            }
            mh$.invokeExact(ctx, ttl_seconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_cache_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_grid_cache_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_grid_cache_clear(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_grid_cache_clear$descriptor() {
        return proj_grid_cache_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_grid_cache_clear(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_grid_cache_clear$handle() {
        return proj_grid_cache_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_grid_cache_clear(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_grid_cache_clear$address() {
        return proj_grid_cache_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_grid_cache_clear(PJ_CONTEXT *ctx)
     * }
     */
    public static void proj_grid_cache_clear(MemorySegment ctx) {
        var mh$ = proj_grid_cache_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_cache_clear", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_download_needed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_is_download_needed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_download_needed(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting)
     * }
     */
    public static FunctionDescriptor proj_is_download_needed$descriptor() {
        return proj_is_download_needed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_download_needed(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting)
     * }
     */
    public static MethodHandle proj_is_download_needed$handle() {
        return proj_is_download_needed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_download_needed(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting)
     * }
     */
    public static MemorySegment proj_is_download_needed$address() {
        return proj_is_download_needed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_download_needed(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting)
     * }
     */
    public static int proj_is_download_needed(MemorySegment ctx, MemorySegment url_or_filename, int ignore_ttl_setting) {
        var mh$ = proj_is_download_needed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_download_needed", ctx, url_or_filename, ignore_ttl_setting);
            }
            return (int)mh$.invokeExact(ctx, url_or_filename, ignore_ttl_setting);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_download_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_download_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_download_file(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting, int (*progress_cbk)(PJ_CONTEXT *, double, void *), void *user_data)
     * }
     */
    public static FunctionDescriptor proj_download_file$descriptor() {
        return proj_download_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_download_file(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting, int (*progress_cbk)(PJ_CONTEXT *, double, void *), void *user_data)
     * }
     */
    public static MethodHandle proj_download_file$handle() {
        return proj_download_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_download_file(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting, int (*progress_cbk)(PJ_CONTEXT *, double, void *), void *user_data)
     * }
     */
    public static MemorySegment proj_download_file$address() {
        return proj_download_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_download_file(PJ_CONTEXT *ctx, const char *url_or_filename, int ignore_ttl_setting, int (*progress_cbk)(PJ_CONTEXT *, double, void *), void *user_data)
     * }
     */
    public static int proj_download_file(MemorySegment ctx, MemorySegment url_or_filename, int ignore_ttl_setting, MemorySegment progress_cbk, MemorySegment user_data) {
        var mh$ = proj_download_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_download_file", ctx, url_or_filename, ignore_ttl_setting, progress_cbk, user_data);
            }
            return (int)mh$.invokeExact(ctx, url_or_filename, ignore_ttl_setting, progress_cbk, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create(PJ_CONTEXT *ctx, const char *definition)
     * }
     */
    public static FunctionDescriptor proj_create$descriptor() {
        return proj_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create(PJ_CONTEXT *ctx, const char *definition)
     * }
     */
    public static MethodHandle proj_create$handle() {
        return proj_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create(PJ_CONTEXT *ctx, const char *definition)
     * }
     */
    public static MemorySegment proj_create$address() {
        return proj_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create(PJ_CONTEXT *ctx, const char *definition)
     * }
     */
    public static MemorySegment proj_create(MemorySegment ctx, MemorySegment definition) {
        var mh$ = proj_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create", ctx, definition);
            }
            return (MemorySegment)mh$.invokeExact(ctx, definition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_argv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_create_argv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_argv(PJ_CONTEXT *ctx, int argc, char **argv)
     * }
     */
    public static FunctionDescriptor proj_create_argv$descriptor() {
        return proj_create_argv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_argv(PJ_CONTEXT *ctx, int argc, char **argv)
     * }
     */
    public static MethodHandle proj_create_argv$handle() {
        return proj_create_argv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_argv(PJ_CONTEXT *ctx, int argc, char **argv)
     * }
     */
    public static MemorySegment proj_create_argv$address() {
        return proj_create_argv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_argv(PJ_CONTEXT *ctx, int argc, char **argv)
     * }
     */
    public static MemorySegment proj_create_argv(MemorySegment ctx, int argc, MemorySegment argv) {
        var mh$ = proj_create_argv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_argv", ctx, argc, argv);
            }
            return (MemorySegment)mh$.invokeExact(ctx, argc, argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_crs_to_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_create_crs_to_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs(PJ_CONTEXT *ctx, const char *source_crs, const char *target_crs, PJ_AREA *area)
     * }
     */
    public static FunctionDescriptor proj_create_crs_to_crs$descriptor() {
        return proj_create_crs_to_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs(PJ_CONTEXT *ctx, const char *source_crs, const char *target_crs, PJ_AREA *area)
     * }
     */
    public static MethodHandle proj_create_crs_to_crs$handle() {
        return proj_create_crs_to_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs(PJ_CONTEXT *ctx, const char *source_crs, const char *target_crs, PJ_AREA *area)
     * }
     */
    public static MemorySegment proj_create_crs_to_crs$address() {
        return proj_create_crs_to_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs(PJ_CONTEXT *ctx, const char *source_crs, const char *target_crs, PJ_AREA *area)
     * }
     */
    public static MemorySegment proj_create_crs_to_crs(MemorySegment ctx, MemorySegment source_crs, MemorySegment target_crs, MemorySegment area) {
        var mh$ = proj_create_crs_to_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_crs_to_crs", ctx, source_crs, target_crs, area);
            }
            return (MemorySegment)mh$.invokeExact(ctx, source_crs, target_crs, area);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_crs_to_crs_from_pj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_create_crs_to_crs_from_pj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs_from_pj(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, PJ_AREA *area, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_create_crs_to_crs_from_pj$descriptor() {
        return proj_create_crs_to_crs_from_pj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs_from_pj(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, PJ_AREA *area, const char *const *options)
     * }
     */
    public static MethodHandle proj_create_crs_to_crs_from_pj$handle() {
        return proj_create_crs_to_crs_from_pj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs_from_pj(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, PJ_AREA *area, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_crs_to_crs_from_pj$address() {
        return proj_create_crs_to_crs_from_pj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_crs_to_crs_from_pj(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, PJ_AREA *area, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_crs_to_crs_from_pj(MemorySegment ctx, MemorySegment source_crs, MemorySegment target_crs, MemorySegment area, MemorySegment options) {
        var mh$ = proj_create_crs_to_crs_from_pj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_crs_to_crs_from_pj", ctx, source_crs, target_crs, area, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, source_crs, target_crs, area, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_normalize_for_visualization {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_normalize_for_visualization");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_normalize_for_visualization(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_normalize_for_visualization$descriptor() {
        return proj_normalize_for_visualization.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_normalize_for_visualization(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_normalize_for_visualization$handle() {
        return proj_normalize_for_visualization.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_normalize_for_visualization(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_normalize_for_visualization$address() {
        return proj_normalize_for_visualization.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_normalize_for_visualization(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_normalize_for_visualization(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_normalize_for_visualization.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_normalize_for_visualization", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_assign_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_assign_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_assign_context(PJ *pj, PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_assign_context$descriptor() {
        return proj_assign_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_assign_context(PJ *pj, PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_assign_context$handle() {
        return proj_assign_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_assign_context(PJ *pj, PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_assign_context$address() {
        return proj_assign_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_assign_context(PJ *pj, PJ_CONTEXT *ctx)
     * }
     */
    public static void proj_assign_context(MemorySegment pj, MemorySegment ctx) {
        var mh$ = proj_assign_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_assign_context", pj, ctx);
            }
            mh$.invokeExact(pj, ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_destroy(PJ *P)
     * }
     */
    public static FunctionDescriptor proj_destroy$descriptor() {
        return proj_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_destroy(PJ *P)
     * }
     */
    public static MethodHandle proj_destroy$handle() {
        return proj_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_destroy(PJ *P)
     * }
     */
    public static MemorySegment proj_destroy$address() {
        return proj_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_destroy(PJ *P)
     * }
     */
    public static MemorySegment proj_destroy(MemorySegment P) {
        var mh$ = proj_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_destroy", P);
            }
            return (MemorySegment)mh$.invokeExact(P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_area_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_area_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_AREA *proj_area_create()
     * }
     */
    public static FunctionDescriptor proj_area_create$descriptor() {
        return proj_area_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_AREA *proj_area_create()
     * }
     */
    public static MethodHandle proj_area_create$handle() {
        return proj_area_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_AREA *proj_area_create()
     * }
     */
    public static MemorySegment proj_area_create$address() {
        return proj_area_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_AREA *proj_area_create()
     * }
     */
    public static MemorySegment proj_area_create() {
        var mh$ = proj_area_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_area_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_area_set_bbox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_area_set_bbox");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_area_set_bbox(PJ_AREA *area, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static FunctionDescriptor proj_area_set_bbox$descriptor() {
        return proj_area_set_bbox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_area_set_bbox(PJ_AREA *area, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static MethodHandle proj_area_set_bbox$handle() {
        return proj_area_set_bbox.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_area_set_bbox(PJ_AREA *area, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static MemorySegment proj_area_set_bbox$address() {
        return proj_area_set_bbox.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_area_set_bbox(PJ_AREA *area, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static void proj_area_set_bbox(MemorySegment area, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree) {
        var mh$ = proj_area_set_bbox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_area_set_bbox", area, west_lon_degree, south_lat_degree, east_lon_degree, north_lat_degree);
            }
            mh$.invokeExact(area, west_lon_degree, south_lat_degree, east_lon_degree, north_lat_degree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_area_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_area_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_area_destroy(PJ_AREA *area)
     * }
     */
    public static FunctionDescriptor proj_area_destroy$descriptor() {
        return proj_area_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_area_destroy(PJ_AREA *area)
     * }
     */
    public static MethodHandle proj_area_destroy$handle() {
        return proj_area_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_area_destroy(PJ_AREA *area)
     * }
     */
    public static MemorySegment proj_area_destroy$address() {
        return proj_area_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_area_destroy(PJ_AREA *area)
     * }
     */
    public static void proj_area_destroy(MemorySegment area) {
        var mh$ = proj_area_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_area_destroy", area);
            }
            mh$.invokeExact(area);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PJ_FWD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PJ_DIRECTION.PJ_FWD = 1
     * }
     */
    public static int PJ_FWD() {
        return PJ_FWD;
    }
    private static final int PJ_IDENT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PJ_DIRECTION.PJ_IDENT = 0
     * }
     */
    public static int PJ_IDENT() {
        return PJ_IDENT;
    }
    private static final int PJ_INV = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum PJ_DIRECTION.PJ_INV = -1
     * }
     */
    public static int PJ_INV() {
        return PJ_INV;
    }

    private static class proj_angular_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_angular_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_angular_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static FunctionDescriptor proj_angular_input$descriptor() {
        return proj_angular_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_angular_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MethodHandle proj_angular_input$handle() {
        return proj_angular_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_angular_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MemorySegment proj_angular_input$address() {
        return proj_angular_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_angular_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static int proj_angular_input(MemorySegment P, int dir) {
        var mh$ = proj_angular_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_angular_input", P, dir);
            }
            return (int)mh$.invokeExact(P, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_angular_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_angular_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_angular_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static FunctionDescriptor proj_angular_output$descriptor() {
        return proj_angular_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_angular_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MethodHandle proj_angular_output$handle() {
        return proj_angular_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_angular_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MemorySegment proj_angular_output$address() {
        return proj_angular_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_angular_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static int proj_angular_output(MemorySegment P, int dir) {
        var mh$ = proj_angular_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_angular_output", P, dir);
            }
            return (int)mh$.invokeExact(P, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_degree_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_degree_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_degree_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static FunctionDescriptor proj_degree_input$descriptor() {
        return proj_degree_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_degree_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MethodHandle proj_degree_input$handle() {
        return proj_degree_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_degree_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MemorySegment proj_degree_input$address() {
        return proj_degree_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_degree_input(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static int proj_degree_input(MemorySegment P, int dir) {
        var mh$ = proj_degree_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_degree_input", P, dir);
            }
            return (int)mh$.invokeExact(P, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_degree_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_degree_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_degree_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static FunctionDescriptor proj_degree_output$descriptor() {
        return proj_degree_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_degree_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MethodHandle proj_degree_output$handle() {
        return proj_degree_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_degree_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static MemorySegment proj_degree_output$address() {
        return proj_degree_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_degree_output(PJ *P, enum PJ_DIRECTION dir)
     * }
     */
    public static int proj_degree_output(MemorySegment P, int dir) {
        var mh$ = proj_degree_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_degree_output", P, dir);
            }
            return (int)mh$.invokeExact(P, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_trans {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_COORD.layout(),
            proj_h.C_POINTER,
            proj_h.C_INT,
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_trans");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_COORD proj_trans(PJ *P, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static FunctionDescriptor proj_trans$descriptor() {
        return proj_trans.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_COORD proj_trans(PJ *P, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static MethodHandle proj_trans$handle() {
        return proj_trans.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_COORD proj_trans(PJ *P, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static MemorySegment proj_trans$address() {
        return proj_trans.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_COORD proj_trans(PJ *P, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static MemorySegment proj_trans(SegmentAllocator allocator, MemorySegment P, int direction, MemorySegment coord) {
        var mh$ = proj_trans.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_trans", allocator, P, direction, coord);
            }
            return (MemorySegment)mh$.invokeExact(allocator, P, direction, coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_trans_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_LONG,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_trans_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_trans_array(PJ *P, PJ_DIRECTION direction, size_t n, PJ_COORD *coord)
     * }
     */
    public static FunctionDescriptor proj_trans_array$descriptor() {
        return proj_trans_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_trans_array(PJ *P, PJ_DIRECTION direction, size_t n, PJ_COORD *coord)
     * }
     */
    public static MethodHandle proj_trans_array$handle() {
        return proj_trans_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_trans_array(PJ *P, PJ_DIRECTION direction, size_t n, PJ_COORD *coord)
     * }
     */
    public static MemorySegment proj_trans_array$address() {
        return proj_trans_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_trans_array(PJ *P, PJ_DIRECTION direction, size_t n, PJ_COORD *coord)
     * }
     */
    public static int proj_trans_array(MemorySegment P, int direction, long n, MemorySegment coord) {
        var mh$ = proj_trans_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_trans_array", P, direction, n, coord);
            }
            return (int)mh$.invokeExact(P, direction, n, coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_trans_generic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_LONG,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_LONG,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_LONG,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_LONG,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_LONG
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_trans_generic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t proj_trans_generic(PJ *P, PJ_DIRECTION direction, double *x, size_t sx, size_t nx, double *y, size_t sy, size_t ny, double *z, size_t sz, size_t nz, double *t, size_t st, size_t nt)
     * }
     */
    public static FunctionDescriptor proj_trans_generic$descriptor() {
        return proj_trans_generic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t proj_trans_generic(PJ *P, PJ_DIRECTION direction, double *x, size_t sx, size_t nx, double *y, size_t sy, size_t ny, double *z, size_t sz, size_t nz, double *t, size_t st, size_t nt)
     * }
     */
    public static MethodHandle proj_trans_generic$handle() {
        return proj_trans_generic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t proj_trans_generic(PJ *P, PJ_DIRECTION direction, double *x, size_t sx, size_t nx, double *y, size_t sy, size_t ny, double *z, size_t sz, size_t nz, double *t, size_t st, size_t nt)
     * }
     */
    public static MemorySegment proj_trans_generic$address() {
        return proj_trans_generic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t proj_trans_generic(PJ *P, PJ_DIRECTION direction, double *x, size_t sx, size_t nx, double *y, size_t sy, size_t ny, double *z, size_t sz, size_t nz, double *t, size_t st, size_t nt)
     * }
     */
    public static long proj_trans_generic(MemorySegment P, int direction, MemorySegment x, long sx, long nx, MemorySegment y, long sy, long ny, MemorySegment z, long sz, long nz, MemorySegment t, long st, long nt) {
        var mh$ = proj_trans_generic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_trans_generic", P, direction, x, sx, nx, y, sy, ny, z, sz, nz, t, st, nt);
            }
            return (long)mh$.invokeExact(P, direction, x, sx, nx, y, sy, ny, z, sz, nz, t, st, nt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_trans_bounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_trans_bounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_trans_bounds(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, double xmin, double ymin, double xmax, double ymax, double *out_xmin, double *out_ymin, double *out_xmax, double *out_ymax, int densify_pts)
     * }
     */
    public static FunctionDescriptor proj_trans_bounds$descriptor() {
        return proj_trans_bounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_trans_bounds(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, double xmin, double ymin, double xmax, double ymax, double *out_xmin, double *out_ymin, double *out_xmax, double *out_ymax, int densify_pts)
     * }
     */
    public static MethodHandle proj_trans_bounds$handle() {
        return proj_trans_bounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_trans_bounds(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, double xmin, double ymin, double xmax, double ymax, double *out_xmin, double *out_ymin, double *out_xmax, double *out_ymax, int densify_pts)
     * }
     */
    public static MemorySegment proj_trans_bounds$address() {
        return proj_trans_bounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_trans_bounds(PJ_CONTEXT *context, PJ *P, PJ_DIRECTION direction, double xmin, double ymin, double xmax, double ymax, double *out_xmin, double *out_ymin, double *out_xmax, double *out_ymax, int densify_pts)
     * }
     */
    public static int proj_trans_bounds(MemorySegment context, MemorySegment P, int direction, double xmin, double ymin, double xmax, double ymax, MemorySegment out_xmin, MemorySegment out_ymin, MemorySegment out_xmax, MemorySegment out_ymax, int densify_pts) {
        var mh$ = proj_trans_bounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_trans_bounds", context, P, direction, xmin, ymin, xmax, ymax, out_xmin, out_ymin, out_xmax, out_ymax, densify_pts);
            }
            return (int)mh$.invokeExact(context, P, direction, xmin, ymin, xmax, ymax, out_xmin, out_ymin, out_xmax, out_ymax, densify_pts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_COORD.layout(),
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_COORD proj_coord(double x, double y, double z, double t)
     * }
     */
    public static FunctionDescriptor proj_coord$descriptor() {
        return proj_coord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_COORD proj_coord(double x, double y, double z, double t)
     * }
     */
    public static MethodHandle proj_coord$handle() {
        return proj_coord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_COORD proj_coord(double x, double y, double z, double t)
     * }
     */
    public static MemorySegment proj_coord$address() {
        return proj_coord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_COORD proj_coord(double x, double y, double z, double t)
     * }
     */
    public static MemorySegment proj_coord(SegmentAllocator allocator, double x, double y, double z, double t) {
        var mh$ = proj_coord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coord", allocator, x, y, z, t);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x, y, z, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_roundtrip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_roundtrip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_roundtrip(PJ *P, PJ_DIRECTION direction, int n, PJ_COORD *coord)
     * }
     */
    public static FunctionDescriptor proj_roundtrip$descriptor() {
        return proj_roundtrip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_roundtrip(PJ *P, PJ_DIRECTION direction, int n, PJ_COORD *coord)
     * }
     */
    public static MethodHandle proj_roundtrip$handle() {
        return proj_roundtrip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_roundtrip(PJ *P, PJ_DIRECTION direction, int n, PJ_COORD *coord)
     * }
     */
    public static MemorySegment proj_roundtrip$address() {
        return proj_roundtrip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_roundtrip(PJ *P, PJ_DIRECTION direction, int n, PJ_COORD *coord)
     * }
     */
    public static double proj_roundtrip(MemorySegment P, int direction, int n, MemorySegment coord) {
        var mh$ = proj_roundtrip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_roundtrip", P, direction, n, coord);
            }
            return (double)mh$.invokeExact(P, direction, n, coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_lp_dist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            PJ_COORD.layout(),
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_lp_dist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_lp_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static FunctionDescriptor proj_lp_dist$descriptor() {
        return proj_lp_dist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_lp_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MethodHandle proj_lp_dist$handle() {
        return proj_lp_dist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_lp_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_lp_dist$address() {
        return proj_lp_dist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_lp_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static double proj_lp_dist(MemorySegment P, MemorySegment a, MemorySegment b) {
        var mh$ = proj_lp_dist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_lp_dist", P, a, b);
            }
            return (double)mh$.invokeExact(P, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_lpz_dist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            PJ_COORD.layout(),
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_lpz_dist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_lpz_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static FunctionDescriptor proj_lpz_dist$descriptor() {
        return proj_lpz_dist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_lpz_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MethodHandle proj_lpz_dist$handle() {
        return proj_lpz_dist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_lpz_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_lpz_dist$address() {
        return proj_lpz_dist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_lpz_dist(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static double proj_lpz_dist(MemorySegment P, MemorySegment a, MemorySegment b) {
        var mh$ = proj_lpz_dist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_lpz_dist", P, a, b);
            }
            return (double)mh$.invokeExact(P, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_xy_dist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            PJ_COORD.layout(),
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_xy_dist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_xy_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static FunctionDescriptor proj_xy_dist$descriptor() {
        return proj_xy_dist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_xy_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MethodHandle proj_xy_dist$handle() {
        return proj_xy_dist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_xy_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_xy_dist$address() {
        return proj_xy_dist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_xy_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static double proj_xy_dist(MemorySegment a, MemorySegment b) {
        var mh$ = proj_xy_dist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_xy_dist", a, b);
            }
            return (double)mh$.invokeExact(a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_xyz_dist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            PJ_COORD.layout(),
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_xyz_dist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_xyz_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static FunctionDescriptor proj_xyz_dist$descriptor() {
        return proj_xyz_dist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_xyz_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MethodHandle proj_xyz_dist$handle() {
        return proj_xyz_dist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_xyz_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_xyz_dist$address() {
        return proj_xyz_dist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_xyz_dist(PJ_COORD a, PJ_COORD b)
     * }
     */
    public static double proj_xyz_dist(MemorySegment a, MemorySegment b) {
        var mh$ = proj_xyz_dist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_xyz_dist", a, b);
            }
            return (double)mh$.invokeExact(a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_geod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_COORD.layout(),
            proj_h.C_POINTER,
            PJ_COORD.layout(),
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_geod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_COORD proj_geod(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static FunctionDescriptor proj_geod$descriptor() {
        return proj_geod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_COORD proj_geod(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MethodHandle proj_geod$handle() {
        return proj_geod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_COORD proj_geod(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_geod$address() {
        return proj_geod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_COORD proj_geod(const PJ *P, PJ_COORD a, PJ_COORD b)
     * }
     */
    public static MemorySegment proj_geod(SegmentAllocator allocator, MemorySegment P, MemorySegment a, MemorySegment b) {
        var mh$ = proj_geod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_geod", allocator, P, a, b);
            }
            return (MemorySegment)mh$.invokeExact(allocator, P, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_errno(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_errno$descriptor() {
        return proj_context_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_errno(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_errno$handle() {
        return proj_context_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_errno(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_errno$address() {
        return proj_context_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_errno(PJ_CONTEXT *ctx)
     * }
     */
    public static int proj_context_errno(MemorySegment ctx) {
        var mh$ = proj_context_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_errno", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_errno(const PJ *P)
     * }
     */
    public static FunctionDescriptor proj_errno$descriptor() {
        return proj_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_errno(const PJ *P)
     * }
     */
    public static MethodHandle proj_errno$handle() {
        return proj_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_errno(const PJ *P)
     * }
     */
    public static MemorySegment proj_errno$address() {
        return proj_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_errno(const PJ *P)
     * }
     */
    public static int proj_errno(MemorySegment P) {
        var mh$ = proj_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_errno", P);
            }
            return (int)mh$.invokeExact(P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_errno_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_errno_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_errno_set(const PJ *P, int err)
     * }
     */
    public static FunctionDescriptor proj_errno_set$descriptor() {
        return proj_errno_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_errno_set(const PJ *P, int err)
     * }
     */
    public static MethodHandle proj_errno_set$handle() {
        return proj_errno_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_errno_set(const PJ *P, int err)
     * }
     */
    public static MemorySegment proj_errno_set$address() {
        return proj_errno_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_errno_set(const PJ *P, int err)
     * }
     */
    public static int proj_errno_set(MemorySegment P, int err) {
        var mh$ = proj_errno_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_errno_set", P, err);
            }
            return (int)mh$.invokeExact(P, err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_errno_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_errno_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_errno_reset(const PJ *P)
     * }
     */
    public static FunctionDescriptor proj_errno_reset$descriptor() {
        return proj_errno_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_errno_reset(const PJ *P)
     * }
     */
    public static MethodHandle proj_errno_reset$handle() {
        return proj_errno_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_errno_reset(const PJ *P)
     * }
     */
    public static MemorySegment proj_errno_reset$address() {
        return proj_errno_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_errno_reset(const PJ *P)
     * }
     */
    public static int proj_errno_reset(MemorySegment P) {
        var mh$ = proj_errno_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_errno_reset", P);
            }
            return (int)mh$.invokeExact(P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_errno_restore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_errno_restore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_errno_restore(const PJ *P, int err)
     * }
     */
    public static FunctionDescriptor proj_errno_restore$descriptor() {
        return proj_errno_restore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_errno_restore(const PJ *P, int err)
     * }
     */
    public static MethodHandle proj_errno_restore$handle() {
        return proj_errno_restore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_errno_restore(const PJ *P, int err)
     * }
     */
    public static MemorySegment proj_errno_restore$address() {
        return proj_errno_restore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_errno_restore(const PJ *P, int err)
     * }
     */
    public static int proj_errno_restore(MemorySegment P, int err) {
        var mh$ = proj_errno_restore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_errno_restore", P, err);
            }
            return (int)mh$.invokeExact(P, err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_errno_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_errno_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_errno_string(int err)
     * }
     */
    public static FunctionDescriptor proj_errno_string$descriptor() {
        return proj_errno_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_errno_string(int err)
     * }
     */
    public static MethodHandle proj_errno_string$handle() {
        return proj_errno_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_errno_string(int err)
     * }
     */
    public static MemorySegment proj_errno_string$address() {
        return proj_errno_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_errno_string(int err)
     * }
     */
    public static MemorySegment proj_errno_string(int err) {
        var mh$ = proj_errno_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_errno_string", err);
            }
            return (MemorySegment)mh$.invokeExact(err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_errno_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_errno_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_context_errno_string(PJ_CONTEXT *ctx, int err)
     * }
     */
    public static FunctionDescriptor proj_context_errno_string$descriptor() {
        return proj_context_errno_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_context_errno_string(PJ_CONTEXT *ctx, int err)
     * }
     */
    public static MethodHandle proj_context_errno_string$handle() {
        return proj_context_errno_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_context_errno_string(PJ_CONTEXT *ctx, int err)
     * }
     */
    public static MemorySegment proj_context_errno_string$address() {
        return proj_context_errno_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_context_errno_string(PJ_CONTEXT *ctx, int err)
     * }
     */
    public static MemorySegment proj_context_errno_string(MemorySegment ctx, int err) {
        var mh$ = proj_context_errno_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_errno_string", ctx, err);
            }
            return (MemorySegment)mh$.invokeExact(ctx, err);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_log_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_log_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_LOG_LEVEL proj_log_level(PJ_CONTEXT *ctx, PJ_LOG_LEVEL log_level)
     * }
     */
    public static FunctionDescriptor proj_log_level$descriptor() {
        return proj_log_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_LOG_LEVEL proj_log_level(PJ_CONTEXT *ctx, PJ_LOG_LEVEL log_level)
     * }
     */
    public static MethodHandle proj_log_level$handle() {
        return proj_log_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_LOG_LEVEL proj_log_level(PJ_CONTEXT *ctx, PJ_LOG_LEVEL log_level)
     * }
     */
    public static MemorySegment proj_log_level$address() {
        return proj_log_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_LOG_LEVEL proj_log_level(PJ_CONTEXT *ctx, PJ_LOG_LEVEL log_level)
     * }
     */
    public static int proj_log_level(MemorySegment ctx, int log_level) {
        var mh$ = proj_log_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_log_level", ctx, log_level);
            }
            return (int)mh$.invokeExact(ctx, log_level);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_log_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_log_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_log_func(PJ_CONTEXT *ctx, void *app_data, PJ_LOG_FUNCTION logf)
     * }
     */
    public static FunctionDescriptor proj_log_func$descriptor() {
        return proj_log_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_log_func(PJ_CONTEXT *ctx, void *app_data, PJ_LOG_FUNCTION logf)
     * }
     */
    public static MethodHandle proj_log_func$handle() {
        return proj_log_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_log_func(PJ_CONTEXT *ctx, void *app_data, PJ_LOG_FUNCTION logf)
     * }
     */
    public static MemorySegment proj_log_func$address() {
        return proj_log_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_log_func(PJ_CONTEXT *ctx, void *app_data, PJ_LOG_FUNCTION logf)
     * }
     */
    public static void proj_log_func(MemorySegment ctx, MemorySegment app_data, MemorySegment logf) {
        var mh$ = proj_log_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_log_func", ctx, app_data, logf);
            }
            mh$.invokeExact(ctx, app_data, logf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_factors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            P5_FACTORS.layout(),
            proj_h.C_POINTER,
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_factors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_FACTORS proj_factors(PJ *P, PJ_COORD lp)
     * }
     */
    public static FunctionDescriptor proj_factors$descriptor() {
        return proj_factors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_FACTORS proj_factors(PJ *P, PJ_COORD lp)
     * }
     */
    public static MethodHandle proj_factors$handle() {
        return proj_factors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_FACTORS proj_factors(PJ *P, PJ_COORD lp)
     * }
     */
    public static MemorySegment proj_factors$address() {
        return proj_factors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_FACTORS proj_factors(PJ *P, PJ_COORD lp)
     * }
     */
    public static MemorySegment proj_factors(SegmentAllocator allocator, MemorySegment P, MemorySegment lp) {
        var mh$ = proj_factors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_factors", allocator, P, lp);
            }
            return (MemorySegment)mh$.invokeExact(allocator, P, lp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_INFO.layout()    );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_INFO proj_info()
     * }
     */
    public static FunctionDescriptor proj_info$descriptor() {
        return proj_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_INFO proj_info()
     * }
     */
    public static MethodHandle proj_info$handle() {
        return proj_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_INFO proj_info()
     * }
     */
    public static MemorySegment proj_info$address() {
        return proj_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_INFO proj_info()
     * }
     */
    public static MemorySegment proj_info(SegmentAllocator allocator) {
        var mh$ = proj_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_info", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_pj_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_PROJ_INFO.layout(),
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_pj_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_PROJ_INFO proj_pj_info(PJ *P)
     * }
     */
    public static FunctionDescriptor proj_pj_info$descriptor() {
        return proj_pj_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_PROJ_INFO proj_pj_info(PJ *P)
     * }
     */
    public static MethodHandle proj_pj_info$handle() {
        return proj_pj_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_PROJ_INFO proj_pj_info(PJ *P)
     * }
     */
    public static MemorySegment proj_pj_info$address() {
        return proj_pj_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_PROJ_INFO proj_pj_info(PJ *P)
     * }
     */
    public static MemorySegment proj_pj_info(SegmentAllocator allocator, MemorySegment P) {
        var mh$ = proj_pj_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_pj_info", allocator, P);
            }
            return (MemorySegment)mh$.invokeExact(allocator, P);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_GRID_INFO.layout(),
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_grid_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_GRID_INFO proj_grid_info(const char *gridname)
     * }
     */
    public static FunctionDescriptor proj_grid_info$descriptor() {
        return proj_grid_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_GRID_INFO proj_grid_info(const char *gridname)
     * }
     */
    public static MethodHandle proj_grid_info$handle() {
        return proj_grid_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_GRID_INFO proj_grid_info(const char *gridname)
     * }
     */
    public static MemorySegment proj_grid_info$address() {
        return proj_grid_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_GRID_INFO proj_grid_info(const char *gridname)
     * }
     */
    public static MemorySegment proj_grid_info(SegmentAllocator allocator, MemorySegment gridname) {
        var mh$ = proj_grid_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_info", allocator, gridname);
            }
            return (MemorySegment)mh$.invokeExact(allocator, gridname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_init_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            PJ_INIT_INFO.layout(),
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_init_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_INIT_INFO proj_init_info(const char *initname)
     * }
     */
    public static FunctionDescriptor proj_init_info$descriptor() {
        return proj_init_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_INIT_INFO proj_init_info(const char *initname)
     * }
     */
    public static MethodHandle proj_init_info$handle() {
        return proj_init_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_INIT_INFO proj_init_info(const char *initname)
     * }
     */
    public static MemorySegment proj_init_info$address() {
        return proj_init_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_INIT_INFO proj_init_info(const char *initname)
     * }
     */
    public static MemorySegment proj_init_info(SegmentAllocator allocator, MemorySegment initname) {
        var mh$ = proj_init_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_init_info", allocator, initname);
            }
            return (MemorySegment)mh$.invokeExact(allocator, initname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_operations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_list_operations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PJ_OPERATIONS *proj_list_operations()
     * }
     */
    public static FunctionDescriptor proj_list_operations$descriptor() {
        return proj_list_operations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PJ_OPERATIONS *proj_list_operations()
     * }
     */
    public static MethodHandle proj_list_operations$handle() {
        return proj_list_operations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PJ_OPERATIONS *proj_list_operations()
     * }
     */
    public static MemorySegment proj_list_operations$address() {
        return proj_list_operations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PJ_OPERATIONS *proj_list_operations()
     * }
     */
    public static MemorySegment proj_list_operations() {
        var mh$ = proj_list_operations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_operations");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_ellps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_list_ellps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PJ_ELLPS *proj_list_ellps()
     * }
     */
    public static FunctionDescriptor proj_list_ellps$descriptor() {
        return proj_list_ellps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PJ_ELLPS *proj_list_ellps()
     * }
     */
    public static MethodHandle proj_list_ellps$handle() {
        return proj_list_ellps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PJ_ELLPS *proj_list_ellps()
     * }
     */
    public static MemorySegment proj_list_ellps$address() {
        return proj_list_ellps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PJ_ELLPS *proj_list_ellps()
     * }
     */
    public static MemorySegment proj_list_ellps() {
        var mh$ = proj_list_ellps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_ellps");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_units {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_list_units");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_units()
     * }
     */
    public static FunctionDescriptor proj_list_units$descriptor() {
        return proj_list_units.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_units()
     * }
     */
    public static MethodHandle proj_list_units$handle() {
        return proj_list_units.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_units()
     * }
     */
    public static MemorySegment proj_list_units$address() {
        return proj_list_units.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_units()
     * }
     */
    public static MemorySegment proj_list_units() {
        var mh$ = proj_list_units.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_units");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_angular_units {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_list_angular_units");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_angular_units()
     * }
     */
    public static FunctionDescriptor proj_list_angular_units$descriptor() {
        return proj_list_angular_units.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_angular_units()
     * }
     */
    public static MethodHandle proj_list_angular_units$handle() {
        return proj_list_angular_units.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_angular_units()
     * }
     */
    public static MemorySegment proj_list_angular_units$address() {
        return proj_list_angular_units.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PJ_UNITS *proj_list_angular_units()
     * }
     */
    public static MemorySegment proj_list_angular_units() {
        var mh$ = proj_list_angular_units.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_angular_units");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_prime_meridians {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_list_prime_meridians");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const PJ_PRIME_MERIDIANS *proj_list_prime_meridians()
     * }
     */
    public static FunctionDescriptor proj_list_prime_meridians$descriptor() {
        return proj_list_prime_meridians.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const PJ_PRIME_MERIDIANS *proj_list_prime_meridians()
     * }
     */
    public static MethodHandle proj_list_prime_meridians$handle() {
        return proj_list_prime_meridians.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const PJ_PRIME_MERIDIANS *proj_list_prime_meridians()
     * }
     */
    public static MemorySegment proj_list_prime_meridians$address() {
        return proj_list_prime_meridians.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const PJ_PRIME_MERIDIANS *proj_list_prime_meridians()
     * }
     */
    public static MemorySegment proj_list_prime_meridians() {
        var mh$ = proj_list_prime_meridians.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_prime_meridians");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_torad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_torad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_torad(double angle_in_degrees)
     * }
     */
    public static FunctionDescriptor proj_torad$descriptor() {
        return proj_torad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_torad(double angle_in_degrees)
     * }
     */
    public static MethodHandle proj_torad$handle() {
        return proj_torad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_torad(double angle_in_degrees)
     * }
     */
    public static MemorySegment proj_torad$address() {
        return proj_torad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_torad(double angle_in_degrees)
     * }
     */
    public static double proj_torad(double angle_in_degrees) {
        var mh$ = proj_torad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_torad", angle_in_degrees);
            }
            return (double)mh$.invokeExact(angle_in_degrees);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_todeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_todeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_todeg(double angle_in_radians)
     * }
     */
    public static FunctionDescriptor proj_todeg$descriptor() {
        return proj_todeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_todeg(double angle_in_radians)
     * }
     */
    public static MethodHandle proj_todeg$handle() {
        return proj_todeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_todeg(double angle_in_radians)
     * }
     */
    public static MemorySegment proj_todeg$address() {
        return proj_todeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_todeg(double angle_in_radians)
     * }
     */
    public static double proj_todeg(double angle_in_radians) {
        var mh$ = proj_todeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_todeg", angle_in_radians);
            }
            return (double)mh$.invokeExact(angle_in_radians);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_dmstor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_dmstor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_dmstor(const char *is, char **rs)
     * }
     */
    public static FunctionDescriptor proj_dmstor$descriptor() {
        return proj_dmstor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_dmstor(const char *is, char **rs)
     * }
     */
    public static MethodHandle proj_dmstor$handle() {
        return proj_dmstor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_dmstor(const char *is, char **rs)
     * }
     */
    public static MemorySegment proj_dmstor$address() {
        return proj_dmstor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_dmstor(const char *is, char **rs)
     * }
     */
    public static double proj_dmstor(MemorySegment is, MemorySegment rs) {
        var mh$ = proj_dmstor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_dmstor", is, rs);
            }
            return (double)mh$.invokeExact(is, rs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_rtodms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_INT,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_rtodms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *proj_rtodms(char *s, double r, int pos, int neg)
     * }
     */
    public static FunctionDescriptor proj_rtodms$descriptor() {
        return proj_rtodms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *proj_rtodms(char *s, double r, int pos, int neg)
     * }
     */
    public static MethodHandle proj_rtodms$handle() {
        return proj_rtodms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *proj_rtodms(char *s, double r, int pos, int neg)
     * }
     */
    public static MemorySegment proj_rtodms$address() {
        return proj_rtodms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *proj_rtodms(char *s, double r, int pos, int neg)
     * }
     */
    public static MemorySegment proj_rtodms(MemorySegment s, double r, int pos, int neg) {
        var mh$ = proj_rtodms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_rtodms", s, r, pos, neg);
            }
            return (MemorySegment)mh$.invokeExact(s, r, pos, neg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_cleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_cleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_cleanup()
     * }
     */
    public static FunctionDescriptor proj_cleanup$descriptor() {
        return proj_cleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_cleanup()
     * }
     */
    public static MethodHandle proj_cleanup$handle() {
        return proj_cleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_cleanup()
     * }
     */
    public static MemorySegment proj_cleanup$address() {
        return proj_cleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_cleanup()
     * }
     */
    public static void proj_cleanup() {
        var mh$ = proj_cleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_cleanup");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef char **PROJ_STRING_LIST
     * }
     */
    public static final AddressLayout PROJ_STRING_LIST = proj_h.C_POINTER;
    private static final int PJ_GUESSED_WKT2_2019 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_WKT2_2019 = 0
     * }
     */
    public static int PJ_GUESSED_WKT2_2019() {
        return PJ_GUESSED_WKT2_2019;
    }
    private static final int PJ_GUESSED_WKT2_2018 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_WKT2_2018 = 0
     * }
     */
    public static int PJ_GUESSED_WKT2_2018() {
        return PJ_GUESSED_WKT2_2018;
    }
    private static final int PJ_GUESSED_WKT2_2015 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_WKT2_2015 = 1
     * }
     */
    public static int PJ_GUESSED_WKT2_2015() {
        return PJ_GUESSED_WKT2_2015;
    }
    private static final int PJ_GUESSED_WKT1_GDAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_WKT1_GDAL = 2
     * }
     */
    public static int PJ_GUESSED_WKT1_GDAL() {
        return PJ_GUESSED_WKT1_GDAL;
    }
    private static final int PJ_GUESSED_WKT1_ESRI = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_WKT1_ESRI = 3
     * }
     */
    public static int PJ_GUESSED_WKT1_ESRI() {
        return PJ_GUESSED_WKT1_ESRI;
    }
    private static final int PJ_GUESSED_NOT_WKT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_GUESSED_NOT_WKT = 4
     * }
     */
    public static int PJ_GUESSED_NOT_WKT() {
        return PJ_GUESSED_NOT_WKT;
    }
    private static final int PJ_CATEGORY_ELLIPSOID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_ELLIPSOID = 0
     * }
     */
    public static int PJ_CATEGORY_ELLIPSOID() {
        return PJ_CATEGORY_ELLIPSOID;
    }
    private static final int PJ_CATEGORY_PRIME_MERIDIAN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_PRIME_MERIDIAN = 1
     * }
     */
    public static int PJ_CATEGORY_PRIME_MERIDIAN() {
        return PJ_CATEGORY_PRIME_MERIDIAN;
    }
    private static final int PJ_CATEGORY_DATUM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_DATUM = 2
     * }
     */
    public static int PJ_CATEGORY_DATUM() {
        return PJ_CATEGORY_DATUM;
    }
    private static final int PJ_CATEGORY_CRS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_CRS = 3
     * }
     */
    public static int PJ_CATEGORY_CRS() {
        return PJ_CATEGORY_CRS;
    }
    private static final int PJ_CATEGORY_COORDINATE_OPERATION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_COORDINATE_OPERATION = 4
     * }
     */
    public static int PJ_CATEGORY_COORDINATE_OPERATION() {
        return PJ_CATEGORY_COORDINATE_OPERATION;
    }
    private static final int PJ_CATEGORY_DATUM_ENSEMBLE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CATEGORY_DATUM_ENSEMBLE = 5
     * }
     */
    public static int PJ_CATEGORY_DATUM_ENSEMBLE() {
        return PJ_CATEGORY_DATUM_ENSEMBLE;
    }
    private static final int PJ_TYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_UNKNOWN = 0
     * }
     */
    public static int PJ_TYPE_UNKNOWN() {
        return PJ_TYPE_UNKNOWN;
    }
    private static final int PJ_TYPE_ELLIPSOID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_ELLIPSOID = 1
     * }
     */
    public static int PJ_TYPE_ELLIPSOID() {
        return PJ_TYPE_ELLIPSOID;
    }
    private static final int PJ_TYPE_PRIME_MERIDIAN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_PRIME_MERIDIAN = 2
     * }
     */
    public static int PJ_TYPE_PRIME_MERIDIAN() {
        return PJ_TYPE_PRIME_MERIDIAN;
    }
    private static final int PJ_TYPE_GEODETIC_REFERENCE_FRAME = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEODETIC_REFERENCE_FRAME = 3
     * }
     */
    public static int PJ_TYPE_GEODETIC_REFERENCE_FRAME() {
        return PJ_TYPE_GEODETIC_REFERENCE_FRAME;
    }
    private static final int PJ_TYPE_DYNAMIC_GEODETIC_REFERENCE_FRAME = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_DYNAMIC_GEODETIC_REFERENCE_FRAME = 4
     * }
     */
    public static int PJ_TYPE_DYNAMIC_GEODETIC_REFERENCE_FRAME() {
        return PJ_TYPE_DYNAMIC_GEODETIC_REFERENCE_FRAME;
    }
    private static final int PJ_TYPE_VERTICAL_REFERENCE_FRAME = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_VERTICAL_REFERENCE_FRAME = 5
     * }
     */
    public static int PJ_TYPE_VERTICAL_REFERENCE_FRAME() {
        return PJ_TYPE_VERTICAL_REFERENCE_FRAME;
    }
    private static final int PJ_TYPE_DYNAMIC_VERTICAL_REFERENCE_FRAME = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_DYNAMIC_VERTICAL_REFERENCE_FRAME = 6
     * }
     */
    public static int PJ_TYPE_DYNAMIC_VERTICAL_REFERENCE_FRAME() {
        return PJ_TYPE_DYNAMIC_VERTICAL_REFERENCE_FRAME;
    }
    private static final int PJ_TYPE_DATUM_ENSEMBLE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_DATUM_ENSEMBLE = 7
     * }
     */
    public static int PJ_TYPE_DATUM_ENSEMBLE() {
        return PJ_TYPE_DATUM_ENSEMBLE;
    }
    private static final int PJ_TYPE_CRS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_CRS = 8
     * }
     */
    public static int PJ_TYPE_CRS() {
        return PJ_TYPE_CRS;
    }
    private static final int PJ_TYPE_GEODETIC_CRS = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEODETIC_CRS = 9
     * }
     */
    public static int PJ_TYPE_GEODETIC_CRS() {
        return PJ_TYPE_GEODETIC_CRS;
    }
    private static final int PJ_TYPE_GEOCENTRIC_CRS = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEOCENTRIC_CRS = 10
     * }
     */
    public static int PJ_TYPE_GEOCENTRIC_CRS() {
        return PJ_TYPE_GEOCENTRIC_CRS;
    }
    private static final int PJ_TYPE_GEOGRAPHIC_CRS = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEOGRAPHIC_CRS = 11
     * }
     */
    public static int PJ_TYPE_GEOGRAPHIC_CRS() {
        return PJ_TYPE_GEOGRAPHIC_CRS;
    }
    private static final int PJ_TYPE_GEOGRAPHIC_2D_CRS = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEOGRAPHIC_2D_CRS = 12
     * }
     */
    public static int PJ_TYPE_GEOGRAPHIC_2D_CRS() {
        return PJ_TYPE_GEOGRAPHIC_2D_CRS;
    }
    private static final int PJ_TYPE_GEOGRAPHIC_3D_CRS = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_GEOGRAPHIC_3D_CRS = 13
     * }
     */
    public static int PJ_TYPE_GEOGRAPHIC_3D_CRS() {
        return PJ_TYPE_GEOGRAPHIC_3D_CRS;
    }
    private static final int PJ_TYPE_VERTICAL_CRS = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_VERTICAL_CRS = 14
     * }
     */
    public static int PJ_TYPE_VERTICAL_CRS() {
        return PJ_TYPE_VERTICAL_CRS;
    }
    private static final int PJ_TYPE_PROJECTED_CRS = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_PROJECTED_CRS = 15
     * }
     */
    public static int PJ_TYPE_PROJECTED_CRS() {
        return PJ_TYPE_PROJECTED_CRS;
    }
    private static final int PJ_TYPE_COMPOUND_CRS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_COMPOUND_CRS = 16
     * }
     */
    public static int PJ_TYPE_COMPOUND_CRS() {
        return PJ_TYPE_COMPOUND_CRS;
    }
    private static final int PJ_TYPE_TEMPORAL_CRS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_TEMPORAL_CRS = 17
     * }
     */
    public static int PJ_TYPE_TEMPORAL_CRS() {
        return PJ_TYPE_TEMPORAL_CRS;
    }
    private static final int PJ_TYPE_ENGINEERING_CRS = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_ENGINEERING_CRS = 18
     * }
     */
    public static int PJ_TYPE_ENGINEERING_CRS() {
        return PJ_TYPE_ENGINEERING_CRS;
    }
    private static final int PJ_TYPE_BOUND_CRS = (int)19L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_BOUND_CRS = 19
     * }
     */
    public static int PJ_TYPE_BOUND_CRS() {
        return PJ_TYPE_BOUND_CRS;
    }
    private static final int PJ_TYPE_OTHER_CRS = (int)20L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_OTHER_CRS = 20
     * }
     */
    public static int PJ_TYPE_OTHER_CRS() {
        return PJ_TYPE_OTHER_CRS;
    }
    private static final int PJ_TYPE_CONVERSION = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_CONVERSION = 21
     * }
     */
    public static int PJ_TYPE_CONVERSION() {
        return PJ_TYPE_CONVERSION;
    }
    private static final int PJ_TYPE_TRANSFORMATION = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_TRANSFORMATION = 22
     * }
     */
    public static int PJ_TYPE_TRANSFORMATION() {
        return PJ_TYPE_TRANSFORMATION;
    }
    private static final int PJ_TYPE_CONCATENATED_OPERATION = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_CONCATENATED_OPERATION = 23
     * }
     */
    public static int PJ_TYPE_CONCATENATED_OPERATION() {
        return PJ_TYPE_CONCATENATED_OPERATION;
    }
    private static final int PJ_TYPE_OTHER_COORDINATE_OPERATION = (int)24L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_OTHER_COORDINATE_OPERATION = 24
     * }
     */
    public static int PJ_TYPE_OTHER_COORDINATE_OPERATION() {
        return PJ_TYPE_OTHER_COORDINATE_OPERATION;
    }
    private static final int PJ_TYPE_TEMPORAL_DATUM = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_TEMPORAL_DATUM = 25
     * }
     */
    public static int PJ_TYPE_TEMPORAL_DATUM() {
        return PJ_TYPE_TEMPORAL_DATUM;
    }
    private static final int PJ_TYPE_ENGINEERING_DATUM = (int)26L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_ENGINEERING_DATUM = 26
     * }
     */
    public static int PJ_TYPE_ENGINEERING_DATUM() {
        return PJ_TYPE_ENGINEERING_DATUM;
    }
    private static final int PJ_TYPE_PARAMETRIC_DATUM = (int)27L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_TYPE_PARAMETRIC_DATUM = 27
     * }
     */
    public static int PJ_TYPE_PARAMETRIC_DATUM() {
        return PJ_TYPE_PARAMETRIC_DATUM;
    }
    private static final int PJ_COMP_STRICT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_COMP_STRICT = 0
     * }
     */
    public static int PJ_COMP_STRICT() {
        return PJ_COMP_STRICT;
    }
    private static final int PJ_COMP_EQUIVALENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_COMP_EQUIVALENT = 1
     * }
     */
    public static int PJ_COMP_EQUIVALENT() {
        return PJ_COMP_EQUIVALENT;
    }
    private static final int PJ_COMP_EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_COMP_EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS = 2
     * }
     */
    public static int PJ_COMP_EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS() {
        return PJ_COMP_EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS;
    }
    private static final int PJ_WKT2_2015 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2015 = 0
     * }
     */
    public static int PJ_WKT2_2015() {
        return PJ_WKT2_2015;
    }
    private static final int PJ_WKT2_2015_SIMPLIFIED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2015_SIMPLIFIED = 1
     * }
     */
    public static int PJ_WKT2_2015_SIMPLIFIED() {
        return PJ_WKT2_2015_SIMPLIFIED;
    }
    private static final int PJ_WKT2_2019 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2019 = 2
     * }
     */
    public static int PJ_WKT2_2019() {
        return PJ_WKT2_2019;
    }
    private static final int PJ_WKT2_2018 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2018 = 2
     * }
     */
    public static int PJ_WKT2_2018() {
        return PJ_WKT2_2018;
    }
    private static final int PJ_WKT2_2019_SIMPLIFIED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2019_SIMPLIFIED = 3
     * }
     */
    public static int PJ_WKT2_2019_SIMPLIFIED() {
        return PJ_WKT2_2019_SIMPLIFIED;
    }
    private static final int PJ_WKT2_2018_SIMPLIFIED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT2_2018_SIMPLIFIED = 3
     * }
     */
    public static int PJ_WKT2_2018_SIMPLIFIED() {
        return PJ_WKT2_2018_SIMPLIFIED;
    }
    private static final int PJ_WKT1_GDAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT1_GDAL = 4
     * }
     */
    public static int PJ_WKT1_GDAL() {
        return PJ_WKT1_GDAL;
    }
    private static final int PJ_WKT1_ESRI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_WKT1_ESRI = 5
     * }
     */
    public static int PJ_WKT1_ESRI() {
        return PJ_WKT1_ESRI;
    }
    private static final int PJ_CRS_EXTENT_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CRS_EXTENT_NONE = 0
     * }
     */
    public static int PJ_CRS_EXTENT_NONE() {
        return PJ_CRS_EXTENT_NONE;
    }
    private static final int PJ_CRS_EXTENT_BOTH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CRS_EXTENT_BOTH = 1
     * }
     */
    public static int PJ_CRS_EXTENT_BOTH() {
        return PJ_CRS_EXTENT_BOTH;
    }
    private static final int PJ_CRS_EXTENT_INTERSECTION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CRS_EXTENT_INTERSECTION = 2
     * }
     */
    public static int PJ_CRS_EXTENT_INTERSECTION() {
        return PJ_CRS_EXTENT_INTERSECTION;
    }
    private static final int PJ_CRS_EXTENT_SMALLEST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CRS_EXTENT_SMALLEST = 3
     * }
     */
    public static int PJ_CRS_EXTENT_SMALLEST() {
        return PJ_CRS_EXTENT_SMALLEST;
    }
    private static final int PROJ_GRID_AVAILABILITY_USED_FOR_SORTING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_GRID_AVAILABILITY_USED_FOR_SORTING = 0
     * }
     */
    public static int PROJ_GRID_AVAILABILITY_USED_FOR_SORTING() {
        return PROJ_GRID_AVAILABILITY_USED_FOR_SORTING;
    }
    private static final int PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID = 1
     * }
     */
    public static int PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID() {
        return PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID;
    }
    private static final int PROJ_GRID_AVAILABILITY_IGNORED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_GRID_AVAILABILITY_IGNORED = 2
     * }
     */
    public static int PROJ_GRID_AVAILABILITY_IGNORED() {
        return PROJ_GRID_AVAILABILITY_IGNORED;
    }
    private static final int PROJ_GRID_AVAILABILITY_KNOWN_AVAILABLE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_GRID_AVAILABILITY_KNOWN_AVAILABLE = 3
     * }
     */
    public static int PROJ_GRID_AVAILABILITY_KNOWN_AVAILABLE() {
        return PROJ_GRID_AVAILABILITY_KNOWN_AVAILABLE;
    }
    private static final int PJ_PROJ_5 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_PROJ_5 = 0
     * }
     */
    public static int PJ_PROJ_5() {
        return PJ_PROJ_5;
    }
    private static final int PJ_PROJ_4 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_PROJ_4 = 1
     * }
     */
    public static int PJ_PROJ_4() {
        return PJ_PROJ_4;
    }
    private static final int PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT = 0
     * }
     */
    public static int PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT() {
        return PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT;
    }
    private static final int PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION = 1
     * }
     */
    public static int PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION() {
        return PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION;
    }
    private static final int PROJ_INTERMEDIATE_CRS_USE_ALWAYS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_INTERMEDIATE_CRS_USE_ALWAYS = 0
     * }
     */
    public static int PROJ_INTERMEDIATE_CRS_USE_ALWAYS() {
        return PROJ_INTERMEDIATE_CRS_USE_ALWAYS;
    }
    private static final int PROJ_INTERMEDIATE_CRS_USE_IF_NO_DIRECT_TRANSFORMATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_INTERMEDIATE_CRS_USE_IF_NO_DIRECT_TRANSFORMATION = 1
     * }
     */
    public static int PROJ_INTERMEDIATE_CRS_USE_IF_NO_DIRECT_TRANSFORMATION() {
        return PROJ_INTERMEDIATE_CRS_USE_IF_NO_DIRECT_TRANSFORMATION;
    }
    private static final int PROJ_INTERMEDIATE_CRS_USE_NEVER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PROJ_INTERMEDIATE_CRS_USE_NEVER = 2
     * }
     */
    public static int PROJ_INTERMEDIATE_CRS_USE_NEVER() {
        return PROJ_INTERMEDIATE_CRS_USE_NEVER;
    }
    private static final int PJ_CS_TYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_UNKNOWN = 0
     * }
     */
    public static int PJ_CS_TYPE_UNKNOWN() {
        return PJ_CS_TYPE_UNKNOWN;
    }
    private static final int PJ_CS_TYPE_CARTESIAN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_CARTESIAN = 1
     * }
     */
    public static int PJ_CS_TYPE_CARTESIAN() {
        return PJ_CS_TYPE_CARTESIAN;
    }
    private static final int PJ_CS_TYPE_ELLIPSOIDAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_ELLIPSOIDAL = 2
     * }
     */
    public static int PJ_CS_TYPE_ELLIPSOIDAL() {
        return PJ_CS_TYPE_ELLIPSOIDAL;
    }
    private static final int PJ_CS_TYPE_VERTICAL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_VERTICAL = 3
     * }
     */
    public static int PJ_CS_TYPE_VERTICAL() {
        return PJ_CS_TYPE_VERTICAL;
    }
    private static final int PJ_CS_TYPE_SPHERICAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_SPHERICAL = 4
     * }
     */
    public static int PJ_CS_TYPE_SPHERICAL() {
        return PJ_CS_TYPE_SPHERICAL;
    }
    private static final int PJ_CS_TYPE_ORDINAL = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_ORDINAL = 5
     * }
     */
    public static int PJ_CS_TYPE_ORDINAL() {
        return PJ_CS_TYPE_ORDINAL;
    }
    private static final int PJ_CS_TYPE_PARAMETRIC = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_PARAMETRIC = 6
     * }
     */
    public static int PJ_CS_TYPE_PARAMETRIC() {
        return PJ_CS_TYPE_PARAMETRIC;
    }
    private static final int PJ_CS_TYPE_DATETIMETEMPORAL = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_DATETIMETEMPORAL = 7
     * }
     */
    public static int PJ_CS_TYPE_DATETIMETEMPORAL() {
        return PJ_CS_TYPE_DATETIMETEMPORAL;
    }
    private static final int PJ_CS_TYPE_TEMPORALCOUNT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_TEMPORALCOUNT = 8
     * }
     */
    public static int PJ_CS_TYPE_TEMPORALCOUNT() {
        return PJ_CS_TYPE_TEMPORALCOUNT;
    }
    private static final int PJ_CS_TYPE_TEMPORALMEASURE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJ_CS_TYPE_TEMPORALMEASURE = 9
     * }
     */
    public static int PJ_CS_TYPE_TEMPORALMEASURE() {
        return PJ_CS_TYPE_TEMPORALMEASURE;
    }

    private static class proj_string_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_string_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_string_list_destroy(PROJ_STRING_LIST list)
     * }
     */
    public static FunctionDescriptor proj_string_list_destroy$descriptor() {
        return proj_string_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_string_list_destroy(PROJ_STRING_LIST list)
     * }
     */
    public static MethodHandle proj_string_list_destroy$handle() {
        return proj_string_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_string_list_destroy(PROJ_STRING_LIST list)
     * }
     */
    public static MemorySegment proj_string_list_destroy$address() {
        return proj_string_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_string_list_destroy(PROJ_STRING_LIST list)
     * }
     */
    public static void proj_string_list_destroy(MemorySegment list) {
        var mh$ = proj_string_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_string_list_destroy", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_autoclose_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_set_autoclose_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_context_set_autoclose_database(PJ_CONTEXT *ctx, int autoclose)
     * }
     */
    public static FunctionDescriptor proj_context_set_autoclose_database$descriptor() {
        return proj_context_set_autoclose_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_context_set_autoclose_database(PJ_CONTEXT *ctx, int autoclose)
     * }
     */
    public static MethodHandle proj_context_set_autoclose_database$handle() {
        return proj_context_set_autoclose_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_context_set_autoclose_database(PJ_CONTEXT *ctx, int autoclose)
     * }
     */
    public static MemorySegment proj_context_set_autoclose_database$address() {
        return proj_context_set_autoclose_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_context_set_autoclose_database(PJ_CONTEXT *ctx, int autoclose)
     * }
     */
    public static void proj_context_set_autoclose_database(MemorySegment ctx, int autoclose) {
        var mh$ = proj_context_set_autoclose_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_autoclose_database", ctx, autoclose);
            }
            mh$.invokeExact(ctx, autoclose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_set_database_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_set_database_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_context_set_database_path(PJ_CONTEXT *ctx, const char *dbPath, const char *const *auxDbPaths, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_context_set_database_path$descriptor() {
        return proj_context_set_database_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_context_set_database_path(PJ_CONTEXT *ctx, const char *dbPath, const char *const *auxDbPaths, const char *const *options)
     * }
     */
    public static MethodHandle proj_context_set_database_path$handle() {
        return proj_context_set_database_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_context_set_database_path(PJ_CONTEXT *ctx, const char *dbPath, const char *const *auxDbPaths, const char *const *options)
     * }
     */
    public static MemorySegment proj_context_set_database_path$address() {
        return proj_context_set_database_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_context_set_database_path(PJ_CONTEXT *ctx, const char *dbPath, const char *const *auxDbPaths, const char *const *options)
     * }
     */
    public static int proj_context_set_database_path(MemorySegment ctx, MemorySegment dbPath, MemorySegment auxDbPaths, MemorySegment options) {
        var mh$ = proj_context_set_database_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_set_database_path", ctx, dbPath, auxDbPaths, options);
            }
            return (int)mh$.invokeExact(ctx, dbPath, auxDbPaths, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_database_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_get_database_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_path(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_context_get_database_path$descriptor() {
        return proj_context_get_database_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_path(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_context_get_database_path$handle() {
        return proj_context_get_database_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_path(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_get_database_path$address() {
        return proj_context_get_database_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_context_get_database_path(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_context_get_database_path(MemorySegment ctx) {
        var mh$ = proj_context_get_database_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_database_path", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_database_metadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_get_database_metadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_metadata(PJ_CONTEXT *ctx, const char *key)
     * }
     */
    public static FunctionDescriptor proj_context_get_database_metadata$descriptor() {
        return proj_context_get_database_metadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_metadata(PJ_CONTEXT *ctx, const char *key)
     * }
     */
    public static MethodHandle proj_context_get_database_metadata$handle() {
        return proj_context_get_database_metadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_context_get_database_metadata(PJ_CONTEXT *ctx, const char *key)
     * }
     */
    public static MemorySegment proj_context_get_database_metadata$address() {
        return proj_context_get_database_metadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_context_get_database_metadata(PJ_CONTEXT *ctx, const char *key)
     * }
     */
    public static MemorySegment proj_context_get_database_metadata(MemorySegment ctx, MemorySegment key) {
        var mh$ = proj_context_get_database_metadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_database_metadata", ctx, key);
            }
            return (MemorySegment)mh$.invokeExact(ctx, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_get_database_structure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_get_database_structure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_context_get_database_structure(PJ_CONTEXT *ctx, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_context_get_database_structure$descriptor() {
        return proj_context_get_database_structure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_context_get_database_structure(PJ_CONTEXT *ctx, const char *const *options)
     * }
     */
    public static MethodHandle proj_context_get_database_structure$handle() {
        return proj_context_get_database_structure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_context_get_database_structure(PJ_CONTEXT *ctx, const char *const *options)
     * }
     */
    public static MemorySegment proj_context_get_database_structure$address() {
        return proj_context_get_database_structure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_context_get_database_structure(PJ_CONTEXT *ctx, const char *const *options)
     * }
     */
    public static MemorySegment proj_context_get_database_structure(MemorySegment ctx, MemorySegment options) {
        var mh$ = proj_context_get_database_structure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_get_database_structure", ctx, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_context_guess_wkt_dialect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_context_guess_wkt_dialect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_GUESSED_WKT_DIALECT proj_context_guess_wkt_dialect(PJ_CONTEXT *ctx, const char *wkt)
     * }
     */
    public static FunctionDescriptor proj_context_guess_wkt_dialect$descriptor() {
        return proj_context_guess_wkt_dialect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_GUESSED_WKT_DIALECT proj_context_guess_wkt_dialect(PJ_CONTEXT *ctx, const char *wkt)
     * }
     */
    public static MethodHandle proj_context_guess_wkt_dialect$handle() {
        return proj_context_guess_wkt_dialect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_GUESSED_WKT_DIALECT proj_context_guess_wkt_dialect(PJ_CONTEXT *ctx, const char *wkt)
     * }
     */
    public static MemorySegment proj_context_guess_wkt_dialect$address() {
        return proj_context_guess_wkt_dialect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_GUESSED_WKT_DIALECT proj_context_guess_wkt_dialect(PJ_CONTEXT *ctx, const char *wkt)
     * }
     */
    public static int proj_context_guess_wkt_dialect(MemorySegment ctx, MemorySegment wkt) {
        var mh$ = proj_context_guess_wkt_dialect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_context_guess_wkt_dialect", ctx, wkt);
            }
            return (int)mh$.invokeExact(ctx, wkt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_from_wkt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_create_from_wkt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_from_wkt(PJ_CONTEXT *ctx, const char *wkt, const char *const *options, PROJ_STRING_LIST *out_warnings, PROJ_STRING_LIST *out_grammar_errors)
     * }
     */
    public static FunctionDescriptor proj_create_from_wkt$descriptor() {
        return proj_create_from_wkt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_from_wkt(PJ_CONTEXT *ctx, const char *wkt, const char *const *options, PROJ_STRING_LIST *out_warnings, PROJ_STRING_LIST *out_grammar_errors)
     * }
     */
    public static MethodHandle proj_create_from_wkt$handle() {
        return proj_create_from_wkt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_from_wkt(PJ_CONTEXT *ctx, const char *wkt, const char *const *options, PROJ_STRING_LIST *out_warnings, PROJ_STRING_LIST *out_grammar_errors)
     * }
     */
    public static MemorySegment proj_create_from_wkt$address() {
        return proj_create_from_wkt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_from_wkt(PJ_CONTEXT *ctx, const char *wkt, const char *const *options, PROJ_STRING_LIST *out_warnings, PROJ_STRING_LIST *out_grammar_errors)
     * }
     */
    public static MemorySegment proj_create_from_wkt(MemorySegment ctx, MemorySegment wkt, MemorySegment options, MemorySegment out_warnings, MemorySegment out_grammar_errors) {
        var mh$ = proj_create_from_wkt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_from_wkt", ctx, wkt, options, out_warnings, out_grammar_errors);
            }
            return (MemorySegment)mh$.invokeExact(ctx, wkt, options, out_warnings, out_grammar_errors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_create_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_create_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, PJ_CATEGORY category, int usePROJAlternativeGridNames, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_create_from_database$descriptor() {
        return proj_create_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_create_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, PJ_CATEGORY category, int usePROJAlternativeGridNames, const char *const *options)
     * }
     */
    public static MethodHandle proj_create_from_database$handle() {
        return proj_create_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_create_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, PJ_CATEGORY category, int usePROJAlternativeGridNames, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_from_database$address() {
        return proj_create_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_create_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, PJ_CATEGORY category, int usePROJAlternativeGridNames, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment code, int category, int usePROJAlternativeGridNames, MemorySegment options) {
        var mh$ = proj_create_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_from_database", ctx, auth_name, code, category, usePROJAlternativeGridNames, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, code, category, usePROJAlternativeGridNames, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_uom_get_info_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_uom_get_info_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_uom_get_info_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char **out_name, double *out_conv_factor, const char **out_category)
     * }
     */
    public static FunctionDescriptor proj_uom_get_info_from_database$descriptor() {
        return proj_uom_get_info_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_uom_get_info_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char **out_name, double *out_conv_factor, const char **out_category)
     * }
     */
    public static MethodHandle proj_uom_get_info_from_database$handle() {
        return proj_uom_get_info_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_uom_get_info_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char **out_name, double *out_conv_factor, const char **out_category)
     * }
     */
    public static MemorySegment proj_uom_get_info_from_database$address() {
        return proj_uom_get_info_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_uom_get_info_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char **out_name, double *out_conv_factor, const char **out_category)
     * }
     */
    public static int proj_uom_get_info_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment code, MemorySegment out_name, MemorySegment out_conv_factor, MemorySegment out_category) {
        var mh$ = proj_uom_get_info_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_uom_get_info_from_database", ctx, auth_name, code, out_name, out_conv_factor, out_category);
            }
            return (int)mh$.invokeExact(ctx, auth_name, code, out_name, out_conv_factor, out_category);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_grid_get_info_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_grid_get_info_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_grid_get_info_from_database(PJ_CONTEXT *ctx, const char *grid_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static FunctionDescriptor proj_grid_get_info_from_database$descriptor() {
        return proj_grid_get_info_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_grid_get_info_from_database(PJ_CONTEXT *ctx, const char *grid_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static MethodHandle proj_grid_get_info_from_database$handle() {
        return proj_grid_get_info_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_grid_get_info_from_database(PJ_CONTEXT *ctx, const char *grid_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static MemorySegment proj_grid_get_info_from_database$address() {
        return proj_grid_get_info_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_grid_get_info_from_database(PJ_CONTEXT *ctx, const char *grid_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static int proj_grid_get_info_from_database(MemorySegment ctx, MemorySegment grid_name, MemorySegment out_full_name, MemorySegment out_package_name, MemorySegment out_url, MemorySegment out_direct_download, MemorySegment out_open_license, MemorySegment out_available) {
        var mh$ = proj_grid_get_info_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_grid_get_info_from_database", ctx, grid_name, out_full_name, out_package_name, out_url, out_direct_download, out_open_license, out_available);
            }
            return (int)mh$.invokeExact(ctx, grid_name, out_full_name, out_package_name, out_url, out_direct_download, out_open_license, out_available);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_clone(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_clone$descriptor() {
        return proj_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_clone(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_clone$handle() {
        return proj_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_clone(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_clone$address() {
        return proj_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_clone(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_clone(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_clone", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_LONG,
            proj_h.C_INT,
            proj_h.C_LONG,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_create_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_from_name(PJ_CONTEXT *ctx, const char *auth_name, const char *searchedName, const PJ_TYPE *types, size_t typesCount, int approximateMatch, size_t limitResultCount, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_create_from_name$descriptor() {
        return proj_create_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_from_name(PJ_CONTEXT *ctx, const char *auth_name, const char *searchedName, const PJ_TYPE *types, size_t typesCount, int approximateMatch, size_t limitResultCount, const char *const *options)
     * }
     */
    public static MethodHandle proj_create_from_name$handle() {
        return proj_create_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_from_name(PJ_CONTEXT *ctx, const char *auth_name, const char *searchedName, const PJ_TYPE *types, size_t typesCount, int approximateMatch, size_t limitResultCount, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_from_name$address() {
        return proj_create_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_from_name(PJ_CONTEXT *ctx, const char *auth_name, const char *searchedName, const PJ_TYPE *types, size_t typesCount, int approximateMatch, size_t limitResultCount, const char *const *options)
     * }
     */
    public static MemorySegment proj_create_from_name(MemorySegment ctx, MemorySegment auth_name, MemorySegment searchedName, MemorySegment types, long typesCount, int approximateMatch, long limitResultCount, MemorySegment options) {
        var mh$ = proj_create_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_from_name", ctx, auth_name, searchedName, types, typesCount, approximateMatch, limitResultCount, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, searchedName, types, typesCount, approximateMatch, limitResultCount, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_TYPE proj_get_type(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_type$descriptor() {
        return proj_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_TYPE proj_get_type(const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_type$handle() {
        return proj_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_TYPE proj_get_type(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_type$address() {
        return proj_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_TYPE proj_get_type(const PJ *obj)
     * }
     */
    public static int proj_get_type(MemorySegment obj) {
        var mh$ = proj_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_type", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_deprecated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_is_deprecated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_deprecated(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_is_deprecated$descriptor() {
        return proj_is_deprecated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_deprecated(const PJ *obj)
     * }
     */
    public static MethodHandle proj_is_deprecated$handle() {
        return proj_is_deprecated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_deprecated(const PJ *obj)
     * }
     */
    public static MemorySegment proj_is_deprecated$address() {
        return proj_is_deprecated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_deprecated(const PJ *obj)
     * }
     */
    public static int proj_is_deprecated(MemorySegment obj) {
        var mh$ = proj_is_deprecated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_deprecated", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_non_deprecated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_non_deprecated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_get_non_deprecated(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_non_deprecated$descriptor() {
        return proj_get_non_deprecated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_get_non_deprecated(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_non_deprecated$handle() {
        return proj_get_non_deprecated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_get_non_deprecated(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_non_deprecated$address() {
        return proj_get_non_deprecated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_get_non_deprecated(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_non_deprecated(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_non_deprecated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_non_deprecated", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_equivalent_to {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_is_equivalent_to");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to(const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static FunctionDescriptor proj_is_equivalent_to$descriptor() {
        return proj_is_equivalent_to.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to(const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static MethodHandle proj_is_equivalent_to$handle() {
        return proj_is_equivalent_to.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to(const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static MemorySegment proj_is_equivalent_to$address() {
        return proj_is_equivalent_to.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_equivalent_to(const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static int proj_is_equivalent_to(MemorySegment obj, MemorySegment other, int criterion) {
        var mh$ = proj_is_equivalent_to.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_equivalent_to", obj, other, criterion);
            }
            return (int)mh$.invokeExact(obj, other, criterion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_equivalent_to_with_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_is_equivalent_to_with_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to_with_ctx(PJ_CONTEXT *ctx, const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static FunctionDescriptor proj_is_equivalent_to_with_ctx$descriptor() {
        return proj_is_equivalent_to_with_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to_with_ctx(PJ_CONTEXT *ctx, const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static MethodHandle proj_is_equivalent_to_with_ctx$handle() {
        return proj_is_equivalent_to_with_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_equivalent_to_with_ctx(PJ_CONTEXT *ctx, const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static MemorySegment proj_is_equivalent_to_with_ctx$address() {
        return proj_is_equivalent_to_with_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_equivalent_to_with_ctx(PJ_CONTEXT *ctx, const PJ *obj, const PJ *other, PJ_COMPARISON_CRITERION criterion)
     * }
     */
    public static int proj_is_equivalent_to_with_ctx(MemorySegment ctx, MemorySegment obj, MemorySegment other, int criterion) {
        var mh$ = proj_is_equivalent_to_with_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_equivalent_to_with_ctx", ctx, obj, other, criterion);
            }
            return (int)mh$.invokeExact(ctx, obj, other, criterion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_is_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_is_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_is_crs(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_is_crs$descriptor() {
        return proj_is_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_is_crs(const PJ *obj)
     * }
     */
    public static MethodHandle proj_is_crs$handle() {
        return proj_is_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_is_crs(const PJ *obj)
     * }
     */
    public static MemorySegment proj_is_crs$address() {
        return proj_is_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_is_crs(const PJ *obj)
     * }
     */
    public static int proj_is_crs(MemorySegment obj) {
        var mh$ = proj_is_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_is_crs", obj);
            }
            return (int)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_name(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_name$descriptor() {
        return proj_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_name(const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_name$handle() {
        return proj_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_name(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_name$address() {
        return proj_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_name(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_name(MemorySegment obj) {
        var mh$ = proj_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_name", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_id_auth_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_id_auth_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_id_auth_name(const PJ *obj, int index)
     * }
     */
    public static FunctionDescriptor proj_get_id_auth_name$descriptor() {
        return proj_get_id_auth_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_id_auth_name(const PJ *obj, int index)
     * }
     */
    public static MethodHandle proj_get_id_auth_name$handle() {
        return proj_get_id_auth_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_id_auth_name(const PJ *obj, int index)
     * }
     */
    public static MemorySegment proj_get_id_auth_name$address() {
        return proj_get_id_auth_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_id_auth_name(const PJ *obj, int index)
     * }
     */
    public static MemorySegment proj_get_id_auth_name(MemorySegment obj, int index) {
        var mh$ = proj_get_id_auth_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_id_auth_name", obj, index);
            }
            return (MemorySegment)mh$.invokeExact(obj, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_id_code {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_id_code");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_id_code(const PJ *obj, int index)
     * }
     */
    public static FunctionDescriptor proj_get_id_code$descriptor() {
        return proj_get_id_code.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_id_code(const PJ *obj, int index)
     * }
     */
    public static MethodHandle proj_get_id_code$handle() {
        return proj_get_id_code.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_id_code(const PJ *obj, int index)
     * }
     */
    public static MemorySegment proj_get_id_code$address() {
        return proj_get_id_code.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_id_code(const PJ *obj, int index)
     * }
     */
    public static MemorySegment proj_get_id_code(MemorySegment obj, int index) {
        var mh$ = proj_get_id_code.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_id_code", obj, index);
            }
            return (MemorySegment)mh$.invokeExact(obj, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_remarks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_remarks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_remarks(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_remarks$descriptor() {
        return proj_get_remarks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_remarks(const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_remarks$handle() {
        return proj_get_remarks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_remarks(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_remarks$address() {
        return proj_get_remarks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_remarks(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_remarks(MemorySegment obj) {
        var mh$ = proj_get_remarks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_remarks", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_scope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_scope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_scope(const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_scope$descriptor() {
        return proj_get_scope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_scope(const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_scope$handle() {
        return proj_get_scope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_scope(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_scope$address() {
        return proj_get_scope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_scope(const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_scope(MemorySegment obj) {
        var mh$ = proj_get_scope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_scope", obj);
            }
            return (MemorySegment)mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_area_of_use {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_area_of_use");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_get_area_of_use(PJ_CONTEXT *ctx, const PJ *obj, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static FunctionDescriptor proj_get_area_of_use$descriptor() {
        return proj_get_area_of_use.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_get_area_of_use(PJ_CONTEXT *ctx, const PJ *obj, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static MethodHandle proj_get_area_of_use$handle() {
        return proj_get_area_of_use.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_get_area_of_use(PJ_CONTEXT *ctx, const PJ *obj, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static MemorySegment proj_get_area_of_use$address() {
        return proj_get_area_of_use.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_get_area_of_use(PJ_CONTEXT *ctx, const PJ *obj, double *out_west_lon_degree, double *out_south_lat_degree, double *out_east_lon_degree, double *out_north_lat_degree, const char **out_area_name)
     * }
     */
    public static int proj_get_area_of_use(MemorySegment ctx, MemorySegment obj, MemorySegment out_west_lon_degree, MemorySegment out_south_lat_degree, MemorySegment out_east_lon_degree, MemorySegment out_north_lat_degree, MemorySegment out_area_name) {
        var mh$ = proj_get_area_of_use.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_area_of_use", ctx, obj, out_west_lon_degree, out_south_lat_degree, out_east_lon_degree, out_north_lat_degree, out_area_name);
            }
            return (int)mh$.invokeExact(ctx, obj, out_west_lon_degree, out_south_lat_degree, out_east_lon_degree, out_north_lat_degree, out_area_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_as_wkt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_as_wkt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_as_wkt(PJ_CONTEXT *ctx, const PJ *obj, PJ_WKT_TYPE type, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_as_wkt$descriptor() {
        return proj_as_wkt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_as_wkt(PJ_CONTEXT *ctx, const PJ *obj, PJ_WKT_TYPE type, const char *const *options)
     * }
     */
    public static MethodHandle proj_as_wkt$handle() {
        return proj_as_wkt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_as_wkt(PJ_CONTEXT *ctx, const PJ *obj, PJ_WKT_TYPE type, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_wkt$address() {
        return proj_as_wkt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_as_wkt(PJ_CONTEXT *ctx, const PJ *obj, PJ_WKT_TYPE type, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_wkt(MemorySegment ctx, MemorySegment obj, int type, MemorySegment options) {
        var mh$ = proj_as_wkt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_as_wkt", ctx, obj, type, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, type, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_as_proj_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_as_proj_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_as_proj_string(PJ_CONTEXT *ctx, const PJ *obj, PJ_PROJ_STRING_TYPE type, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_as_proj_string$descriptor() {
        return proj_as_proj_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_as_proj_string(PJ_CONTEXT *ctx, const PJ *obj, PJ_PROJ_STRING_TYPE type, const char *const *options)
     * }
     */
    public static MethodHandle proj_as_proj_string$handle() {
        return proj_as_proj_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_as_proj_string(PJ_CONTEXT *ctx, const PJ *obj, PJ_PROJ_STRING_TYPE type, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_proj_string$address() {
        return proj_as_proj_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_as_proj_string(PJ_CONTEXT *ctx, const PJ *obj, PJ_PROJ_STRING_TYPE type, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_proj_string(MemorySegment ctx, MemorySegment obj, int type, MemorySegment options) {
        var mh$ = proj_as_proj_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_as_proj_string", ctx, obj, type, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, type, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_as_projjson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_as_projjson");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_as_projjson(PJ_CONTEXT *ctx, const PJ *obj, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_as_projjson$descriptor() {
        return proj_as_projjson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_as_projjson(PJ_CONTEXT *ctx, const PJ *obj, const char *const *options)
     * }
     */
    public static MethodHandle proj_as_projjson$handle() {
        return proj_as_projjson.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_as_projjson(PJ_CONTEXT *ctx, const PJ *obj, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_projjson$address() {
        return proj_as_projjson.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_as_projjson(PJ_CONTEXT *ctx, const PJ *obj, const char *const *options)
     * }
     */
    public static MemorySegment proj_as_projjson(MemorySegment ctx, MemorySegment obj, MemorySegment options) {
        var mh$ = proj_as_projjson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_as_projjson", ctx, obj, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_source_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_source_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_get_source_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_source_crs$descriptor() {
        return proj_get_source_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_get_source_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_source_crs$handle() {
        return proj_get_source_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_get_source_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_source_crs$address() {
        return proj_get_source_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_get_source_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_source_crs(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_source_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_source_crs", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_target_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_target_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_get_target_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_target_crs$descriptor() {
        return proj_get_target_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_get_target_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_target_crs$handle() {
        return proj_get_target_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_get_target_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_target_crs$address() {
        return proj_get_target_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_get_target_crs(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_target_crs(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_target_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_target_crs", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_identify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_identify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_identify(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *const *options, int **out_confidence)
     * }
     */
    public static FunctionDescriptor proj_identify$descriptor() {
        return proj_identify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_identify(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *const *options, int **out_confidence)
     * }
     */
    public static MethodHandle proj_identify$handle() {
        return proj_identify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_identify(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *const *options, int **out_confidence)
     * }
     */
    public static MemorySegment proj_identify$address() {
        return proj_identify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_identify(PJ_CONTEXT *ctx, const PJ *obj, const char *auth_name, const char *const *options, int **out_confidence)
     * }
     */
    public static MemorySegment proj_identify(MemorySegment ctx, MemorySegment obj, MemorySegment auth_name, MemorySegment options, MemorySegment out_confidence) {
        var mh$ = proj_identify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_identify", ctx, obj, auth_name, options, out_confidence);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj, auth_name, options, out_confidence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_geoid_models_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_geoid_models_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_geoid_models_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_get_geoid_models_from_database$descriptor() {
        return proj_get_geoid_models_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_geoid_models_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char *const *options)
     * }
     */
    public static MethodHandle proj_get_geoid_models_from_database$handle() {
        return proj_get_geoid_models_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_geoid_models_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char *const *options)
     * }
     */
    public static MemorySegment proj_get_geoid_models_from_database$address() {
        return proj_get_geoid_models_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_geoid_models_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *code, const char *const *options)
     * }
     */
    public static MemorySegment proj_get_geoid_models_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment code, MemorySegment options) {
        var mh$ = proj_get_geoid_models_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_geoid_models_from_database", ctx, auth_name, code, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, code, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_int_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_int_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_int_list_destroy(int *list)
     * }
     */
    public static FunctionDescriptor proj_int_list_destroy$descriptor() {
        return proj_int_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_int_list_destroy(int *list)
     * }
     */
    public static MethodHandle proj_int_list_destroy$handle() {
        return proj_int_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_int_list_destroy(int *list)
     * }
     */
    public static MemorySegment proj_int_list_destroy$address() {
        return proj_int_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_int_list_destroy(int *list)
     * }
     */
    public static void proj_int_list_destroy(MemorySegment list) {
        var mh$ = proj_int_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_int_list_destroy", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_authorities_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_authorities_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_authorities_from_database(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_get_authorities_from_database$descriptor() {
        return proj_get_authorities_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_authorities_from_database(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_get_authorities_from_database$handle() {
        return proj_get_authorities_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_authorities_from_database(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_get_authorities_from_database$address() {
        return proj_get_authorities_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_authorities_from_database(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_get_authorities_from_database(MemorySegment ctx) {
        var mh$ = proj_get_authorities_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_authorities_from_database", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_codes_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_codes_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_codes_from_database(PJ_CONTEXT *ctx, const char *auth_name, PJ_TYPE type, int allow_deprecated)
     * }
     */
    public static FunctionDescriptor proj_get_codes_from_database$descriptor() {
        return proj_get_codes_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_codes_from_database(PJ_CONTEXT *ctx, const char *auth_name, PJ_TYPE type, int allow_deprecated)
     * }
     */
    public static MethodHandle proj_get_codes_from_database$handle() {
        return proj_get_codes_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_codes_from_database(PJ_CONTEXT *ctx, const char *auth_name, PJ_TYPE type, int allow_deprecated)
     * }
     */
    public static MemorySegment proj_get_codes_from_database$address() {
        return proj_get_codes_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_codes_from_database(PJ_CONTEXT *ctx, const char *auth_name, PJ_TYPE type, int allow_deprecated)
     * }
     */
    public static MemorySegment proj_get_codes_from_database(MemorySegment ctx, MemorySegment auth_name, int type, int allow_deprecated) {
        var mh$ = proj_get_codes_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_codes_from_database", ctx, auth_name, type, allow_deprecated);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, type, allow_deprecated);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_celestial_body_list_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_celestial_body_list_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_CELESTIAL_BODY_INFO **proj_get_celestial_body_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, int *out_result_count)
     * }
     */
    public static FunctionDescriptor proj_get_celestial_body_list_from_database$descriptor() {
        return proj_get_celestial_body_list_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_CELESTIAL_BODY_INFO **proj_get_celestial_body_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, int *out_result_count)
     * }
     */
    public static MethodHandle proj_get_celestial_body_list_from_database$handle() {
        return proj_get_celestial_body_list_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_CELESTIAL_BODY_INFO **proj_get_celestial_body_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_celestial_body_list_from_database$address() {
        return proj_get_celestial_body_list_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_CELESTIAL_BODY_INFO **proj_get_celestial_body_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_celestial_body_list_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment out_result_count) {
        var mh$ = proj_get_celestial_body_list_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_celestial_body_list_from_database", ctx, auth_name, out_result_count);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, out_result_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_celestial_body_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_celestial_body_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_celestial_body_list_destroy(PROJ_CELESTIAL_BODY_INFO **list)
     * }
     */
    public static FunctionDescriptor proj_celestial_body_list_destroy$descriptor() {
        return proj_celestial_body_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_celestial_body_list_destroy(PROJ_CELESTIAL_BODY_INFO **list)
     * }
     */
    public static MethodHandle proj_celestial_body_list_destroy$handle() {
        return proj_celestial_body_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_celestial_body_list_destroy(PROJ_CELESTIAL_BODY_INFO **list)
     * }
     */
    public static MemorySegment proj_celestial_body_list_destroy$address() {
        return proj_celestial_body_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_celestial_body_list_destroy(PROJ_CELESTIAL_BODY_INFO **list)
     * }
     */
    public static void proj_celestial_body_list_destroy(MemorySegment list) {
        var mh$ = proj_celestial_body_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_celestial_body_list_destroy", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_crs_list_parameters_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER    );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_crs_list_parameters_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_CRS_LIST_PARAMETERS *proj_get_crs_list_parameters_create()
     * }
     */
    public static FunctionDescriptor proj_get_crs_list_parameters_create$descriptor() {
        return proj_get_crs_list_parameters_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_CRS_LIST_PARAMETERS *proj_get_crs_list_parameters_create()
     * }
     */
    public static MethodHandle proj_get_crs_list_parameters_create$handle() {
        return proj_get_crs_list_parameters_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_CRS_LIST_PARAMETERS *proj_get_crs_list_parameters_create()
     * }
     */
    public static MemorySegment proj_get_crs_list_parameters_create$address() {
        return proj_get_crs_list_parameters_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_CRS_LIST_PARAMETERS *proj_get_crs_list_parameters_create()
     * }
     */
    public static MemorySegment proj_get_crs_list_parameters_create() {
        var mh$ = proj_get_crs_list_parameters_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_crs_list_parameters_create");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_crs_list_parameters_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_crs_list_parameters_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_get_crs_list_parameters_destroy(PROJ_CRS_LIST_PARAMETERS *params)
     * }
     */
    public static FunctionDescriptor proj_get_crs_list_parameters_destroy$descriptor() {
        return proj_get_crs_list_parameters_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_get_crs_list_parameters_destroy(PROJ_CRS_LIST_PARAMETERS *params)
     * }
     */
    public static MethodHandle proj_get_crs_list_parameters_destroy$handle() {
        return proj_get_crs_list_parameters_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_get_crs_list_parameters_destroy(PROJ_CRS_LIST_PARAMETERS *params)
     * }
     */
    public static MemorySegment proj_get_crs_list_parameters_destroy$address() {
        return proj_get_crs_list_parameters_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_get_crs_list_parameters_destroy(PROJ_CRS_LIST_PARAMETERS *params)
     * }
     */
    public static void proj_get_crs_list_parameters_destroy(MemorySegment params) {
        var mh$ = proj_get_crs_list_parameters_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_crs_list_parameters_destroy", params);
            }
            mh$.invokeExact(params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_crs_info_list_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_crs_info_list_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_CRS_INFO **proj_get_crs_info_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, const PROJ_CRS_LIST_PARAMETERS *params, int *out_result_count)
     * }
     */
    public static FunctionDescriptor proj_get_crs_info_list_from_database$descriptor() {
        return proj_get_crs_info_list_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_CRS_INFO **proj_get_crs_info_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, const PROJ_CRS_LIST_PARAMETERS *params, int *out_result_count)
     * }
     */
    public static MethodHandle proj_get_crs_info_list_from_database$handle() {
        return proj_get_crs_info_list_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_CRS_INFO **proj_get_crs_info_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, const PROJ_CRS_LIST_PARAMETERS *params, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_crs_info_list_from_database$address() {
        return proj_get_crs_info_list_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_CRS_INFO **proj_get_crs_info_list_from_database(PJ_CONTEXT *ctx, const char *auth_name, const PROJ_CRS_LIST_PARAMETERS *params, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_crs_info_list_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment params, MemorySegment out_result_count) {
        var mh$ = proj_get_crs_info_list_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_crs_info_list_from_database", ctx, auth_name, params, out_result_count);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, params, out_result_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_info_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_crs_info_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_crs_info_list_destroy(PROJ_CRS_INFO **list)
     * }
     */
    public static FunctionDescriptor proj_crs_info_list_destroy$descriptor() {
        return proj_crs_info_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_crs_info_list_destroy(PROJ_CRS_INFO **list)
     * }
     */
    public static MethodHandle proj_crs_info_list_destroy$handle() {
        return proj_crs_info_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_crs_info_list_destroy(PROJ_CRS_INFO **list)
     * }
     */
    public static MemorySegment proj_crs_info_list_destroy$address() {
        return proj_crs_info_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_crs_info_list_destroy(PROJ_CRS_INFO **list)
     * }
     */
    public static void proj_crs_info_list_destroy(MemorySegment list) {
        var mh$ = proj_crs_info_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_info_list_destroy", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_units_from_database {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_units_from_database");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_UNIT_INFO **proj_get_units_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *category, int allow_deprecated, int *out_result_count)
     * }
     */
    public static FunctionDescriptor proj_get_units_from_database$descriptor() {
        return proj_get_units_from_database.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_UNIT_INFO **proj_get_units_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *category, int allow_deprecated, int *out_result_count)
     * }
     */
    public static MethodHandle proj_get_units_from_database$handle() {
        return proj_get_units_from_database.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_UNIT_INFO **proj_get_units_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *category, int allow_deprecated, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_units_from_database$address() {
        return proj_get_units_from_database.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_UNIT_INFO **proj_get_units_from_database(PJ_CONTEXT *ctx, const char *auth_name, const char *category, int allow_deprecated, int *out_result_count)
     * }
     */
    public static MemorySegment proj_get_units_from_database(MemorySegment ctx, MemorySegment auth_name, MemorySegment category, int allow_deprecated, MemorySegment out_result_count) {
        var mh$ = proj_get_units_from_database.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_units_from_database", ctx, auth_name, category, allow_deprecated, out_result_count);
            }
            return (MemorySegment)mh$.invokeExact(ctx, auth_name, category, allow_deprecated, out_result_count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_unit_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_unit_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_unit_list_destroy(PROJ_UNIT_INFO **list)
     * }
     */
    public static FunctionDescriptor proj_unit_list_destroy$descriptor() {
        return proj_unit_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_unit_list_destroy(PROJ_UNIT_INFO **list)
     * }
     */
    public static MethodHandle proj_unit_list_destroy$handle() {
        return proj_unit_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_unit_list_destroy(PROJ_UNIT_INFO **list)
     * }
     */
    public static MemorySegment proj_unit_list_destroy$address() {
        return proj_unit_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_unit_list_destroy(PROJ_UNIT_INFO **list)
     * }
     */
    public static void proj_unit_list_destroy(MemorySegment list) {
        var mh$ = proj_unit_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_unit_list_destroy", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_insert_object_session_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_insert_object_session_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_INSERT_SESSION *proj_insert_object_session_create(PJ_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_insert_object_session_create$descriptor() {
        return proj_insert_object_session_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_INSERT_SESSION *proj_insert_object_session_create(PJ_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_insert_object_session_create$handle() {
        return proj_insert_object_session_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_INSERT_SESSION *proj_insert_object_session_create(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_insert_object_session_create$address() {
        return proj_insert_object_session_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_INSERT_SESSION *proj_insert_object_session_create(PJ_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_insert_object_session_create(MemorySegment ctx) {
        var mh$ = proj_insert_object_session_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_insert_object_session_create", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_insert_object_session_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_insert_object_session_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_insert_object_session_destroy(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session)
     * }
     */
    public static FunctionDescriptor proj_insert_object_session_destroy$descriptor() {
        return proj_insert_object_session_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_insert_object_session_destroy(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session)
     * }
     */
    public static MethodHandle proj_insert_object_session_destroy$handle() {
        return proj_insert_object_session_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_insert_object_session_destroy(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session)
     * }
     */
    public static MemorySegment proj_insert_object_session_destroy$address() {
        return proj_insert_object_session_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_insert_object_session_destroy(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session)
     * }
     */
    public static void proj_insert_object_session_destroy(MemorySegment ctx, MemorySegment session) {
        var mh$ = proj_insert_object_session_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_insert_object_session_destroy", ctx, session);
            }
            mh$.invokeExact(ctx, session);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_insert_statements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_insert_statements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_insert_statements(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session, const PJ *object, const char *authority, const char *code, int numeric_codes, const char *const *allowed_authorities, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_get_insert_statements$descriptor() {
        return proj_get_insert_statements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_insert_statements(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session, const PJ *object, const char *authority, const char *code, int numeric_codes, const char *const *allowed_authorities, const char *const *options)
     * }
     */
    public static MethodHandle proj_get_insert_statements$handle() {
        return proj_get_insert_statements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_insert_statements(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session, const PJ *object, const char *authority, const char *code, int numeric_codes, const char *const *allowed_authorities, const char *const *options)
     * }
     */
    public static MemorySegment proj_get_insert_statements$address() {
        return proj_get_insert_statements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PROJ_STRING_LIST proj_get_insert_statements(PJ_CONTEXT *ctx, PJ_INSERT_SESSION *session, const PJ *object, const char *authority, const char *code, int numeric_codes, const char *const *allowed_authorities, const char *const *options)
     * }
     */
    public static MemorySegment proj_get_insert_statements(MemorySegment ctx, MemorySegment session, MemorySegment object, MemorySegment authority, MemorySegment code, int numeric_codes, MemorySegment allowed_authorities, MemorySegment options) {
        var mh$ = proj_get_insert_statements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_insert_statements", ctx, session, object, authority, code, numeric_codes, allowed_authorities, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, session, object, authority, code, numeric_codes, allowed_authorities, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_suggests_code_for {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_suggests_code_for");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *proj_suggests_code_for(PJ_CONTEXT *ctx, const PJ *object, const char *authority, int numeric_code, const char *const *options)
     * }
     */
    public static FunctionDescriptor proj_suggests_code_for$descriptor() {
        return proj_suggests_code_for.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *proj_suggests_code_for(PJ_CONTEXT *ctx, const PJ *object, const char *authority, int numeric_code, const char *const *options)
     * }
     */
    public static MethodHandle proj_suggests_code_for$handle() {
        return proj_suggests_code_for.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *proj_suggests_code_for(PJ_CONTEXT *ctx, const PJ *object, const char *authority, int numeric_code, const char *const *options)
     * }
     */
    public static MemorySegment proj_suggests_code_for$address() {
        return proj_suggests_code_for.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *proj_suggests_code_for(PJ_CONTEXT *ctx, const PJ *object, const char *authority, int numeric_code, const char *const *options)
     * }
     */
    public static MemorySegment proj_suggests_code_for(MemorySegment ctx, MemorySegment object, MemorySegment authority, int numeric_code, MemorySegment options) {
        var mh$ = proj_suggests_code_for.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_suggests_code_for", ctx, object, authority, numeric_code, options);
            }
            return (MemorySegment)mh$.invokeExact(ctx, object, authority, numeric_code, options);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_string_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_string_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_string_destroy(char *str)
     * }
     */
    public static FunctionDescriptor proj_string_destroy$descriptor() {
        return proj_string_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_string_destroy(char *str)
     * }
     */
    public static MethodHandle proj_string_destroy$handle() {
        return proj_string_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_string_destroy(char *str)
     * }
     */
    public static MemorySegment proj_string_destroy$address() {
        return proj_string_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_string_destroy(char *str)
     * }
     */
    public static void proj_string_destroy(MemorySegment str) {
        var mh$ = proj_string_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_string_destroy", str);
            }
            mh$.invokeExact(str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_operation_factory_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_create_operation_factory_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OPERATION_FACTORY_CONTEXT *proj_create_operation_factory_context(PJ_CONTEXT *ctx, const char *authority)
     * }
     */
    public static FunctionDescriptor proj_create_operation_factory_context$descriptor() {
        return proj_create_operation_factory_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OPERATION_FACTORY_CONTEXT *proj_create_operation_factory_context(PJ_CONTEXT *ctx, const char *authority)
     * }
     */
    public static MethodHandle proj_create_operation_factory_context$handle() {
        return proj_create_operation_factory_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OPERATION_FACTORY_CONTEXT *proj_create_operation_factory_context(PJ_CONTEXT *ctx, const char *authority)
     * }
     */
    public static MemorySegment proj_create_operation_factory_context$address() {
        return proj_create_operation_factory_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OPERATION_FACTORY_CONTEXT *proj_create_operation_factory_context(PJ_CONTEXT *ctx, const char *authority)
     * }
     */
    public static MemorySegment proj_create_operation_factory_context(MemorySegment ctx, MemorySegment authority) {
        var mh$ = proj_create_operation_factory_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_operation_factory_context", ctx, authority);
            }
            return (MemorySegment)mh$.invokeExact(ctx, authority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_destroy(PJ_OPERATION_FACTORY_CONTEXT *ctx)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_destroy$descriptor() {
        return proj_operation_factory_context_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_destroy(PJ_OPERATION_FACTORY_CONTEXT *ctx)
     * }
     */
    public static MethodHandle proj_operation_factory_context_destroy$handle() {
        return proj_operation_factory_context_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_destroy(PJ_OPERATION_FACTORY_CONTEXT *ctx)
     * }
     */
    public static MemorySegment proj_operation_factory_context_destroy$address() {
        return proj_operation_factory_context_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_destroy(PJ_OPERATION_FACTORY_CONTEXT *ctx)
     * }
     */
    public static void proj_operation_factory_context_destroy(MemorySegment ctx) {
        var mh$ = proj_operation_factory_context_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_destroy", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_desired_accuracy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_set_desired_accuracy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_desired_accuracy(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double accuracy)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_desired_accuracy$descriptor() {
        return proj_operation_factory_context_set_desired_accuracy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_desired_accuracy(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double accuracy)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_desired_accuracy$handle() {
        return proj_operation_factory_context_set_desired_accuracy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_desired_accuracy(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double accuracy)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_desired_accuracy$address() {
        return proj_operation_factory_context_set_desired_accuracy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_desired_accuracy(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double accuracy)
     * }
     */
    public static void proj_operation_factory_context_set_desired_accuracy(MemorySegment ctx, MemorySegment factory_ctx, double accuracy) {
        var mh$ = proj_operation_factory_context_set_desired_accuracy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_desired_accuracy", ctx, factory_ctx, accuracy);
            }
            mh$.invokeExact(ctx, factory_ctx, accuracy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_area_of_interest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE,
            proj_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_set_area_of_interest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_area_of_interest$descriptor() {
        return proj_operation_factory_context_set_area_of_interest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_area_of_interest$handle() {
        return proj_operation_factory_context_set_area_of_interest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_area_of_interest$address() {
        return proj_operation_factory_context_set_area_of_interest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_area_of_interest(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree)
     * }
     */
    public static void proj_operation_factory_context_set_area_of_interest(MemorySegment ctx, MemorySegment factory_ctx, double west_lon_degree, double south_lat_degree, double east_lon_degree, double north_lat_degree) {
        var mh$ = proj_operation_factory_context_set_area_of_interest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_area_of_interest", ctx, factory_ctx, west_lon_degree, south_lat_degree, east_lon_degree, north_lat_degree);
            }
            mh$.invokeExact(ctx, factory_ctx, west_lon_degree, south_lat_degree, east_lon_degree, north_lat_degree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_crs_extent_use {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_set_crs_extent_use");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_crs_extent_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_CRS_EXTENT_USE use)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_crs_extent_use$descriptor() {
        return proj_operation_factory_context_set_crs_extent_use.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_crs_extent_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_CRS_EXTENT_USE use)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_crs_extent_use$handle() {
        return proj_operation_factory_context_set_crs_extent_use.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_crs_extent_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_CRS_EXTENT_USE use)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_crs_extent_use$address() {
        return proj_operation_factory_context_set_crs_extent_use.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_crs_extent_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_CRS_EXTENT_USE use)
     * }
     */
    public static void proj_operation_factory_context_set_crs_extent_use(MemorySegment ctx, MemorySegment factory_ctx, int use) {
        var mh$ = proj_operation_factory_context_set_crs_extent_use.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_crs_extent_use", ctx, factory_ctx, use);
            }
            mh$.invokeExact(ctx, factory_ctx, use);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_spatial_criterion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_set_spatial_criterion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_spatial_criterion(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_SPATIAL_CRITERION criterion)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_spatial_criterion$descriptor() {
        return proj_operation_factory_context_set_spatial_criterion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_spatial_criterion(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_SPATIAL_CRITERION criterion)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_spatial_criterion$handle() {
        return proj_operation_factory_context_set_spatial_criterion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_spatial_criterion(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_SPATIAL_CRITERION criterion)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_spatial_criterion$address() {
        return proj_operation_factory_context_set_spatial_criterion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_spatial_criterion(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_SPATIAL_CRITERION criterion)
     * }
     */
    public static void proj_operation_factory_context_set_spatial_criterion(MemorySegment ctx, MemorySegment factory_ctx, int criterion) {
        var mh$ = proj_operation_factory_context_set_spatial_criterion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_spatial_criterion", ctx, factory_ctx, criterion);
            }
            mh$.invokeExact(ctx, factory_ctx, criterion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_grid_availability_use {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_set_grid_availability_use");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_grid_availability_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_GRID_AVAILABILITY_USE use)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_grid_availability_use$descriptor() {
        return proj_operation_factory_context_set_grid_availability_use.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_grid_availability_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_GRID_AVAILABILITY_USE use)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_grid_availability_use$handle() {
        return proj_operation_factory_context_set_grid_availability_use.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_grid_availability_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_GRID_AVAILABILITY_USE use)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_grid_availability_use$address() {
        return proj_operation_factory_context_set_grid_availability_use.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_grid_availability_use(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_GRID_AVAILABILITY_USE use)
     * }
     */
    public static void proj_operation_factory_context_set_grid_availability_use(MemorySegment ctx, MemorySegment factory_ctx, int use) {
        var mh$ = proj_operation_factory_context_set_grid_availability_use.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_grid_availability_use", ctx, factory_ctx, use);
            }
            mh$.invokeExact(ctx, factory_ctx, use);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_use_proj_alternative_grid_names {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_set_use_proj_alternative_grid_names");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_use_proj_alternative_grid_names(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int usePROJNames)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_use_proj_alternative_grid_names$descriptor() {
        return proj_operation_factory_context_set_use_proj_alternative_grid_names.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_use_proj_alternative_grid_names(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int usePROJNames)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_use_proj_alternative_grid_names$handle() {
        return proj_operation_factory_context_set_use_proj_alternative_grid_names.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_use_proj_alternative_grid_names(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int usePROJNames)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_use_proj_alternative_grid_names$address() {
        return proj_operation_factory_context_set_use_proj_alternative_grid_names.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_use_proj_alternative_grid_names(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int usePROJNames)
     * }
     */
    public static void proj_operation_factory_context_set_use_proj_alternative_grid_names(MemorySegment ctx, MemorySegment factory_ctx, int usePROJNames) {
        var mh$ = proj_operation_factory_context_set_use_proj_alternative_grid_names.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_use_proj_alternative_grid_names", ctx, factory_ctx, usePROJNames);
            }
            mh$.invokeExact(ctx, factory_ctx, usePROJNames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_allow_use_intermediate_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_set_allow_use_intermediate_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_use_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_INTERMEDIATE_CRS_USE use)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_allow_use_intermediate_crs$descriptor() {
        return proj_operation_factory_context_set_allow_use_intermediate_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_use_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_INTERMEDIATE_CRS_USE use)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_allow_use_intermediate_crs$handle() {
        return proj_operation_factory_context_set_allow_use_intermediate_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_use_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_INTERMEDIATE_CRS_USE use)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_allow_use_intermediate_crs$address() {
        return proj_operation_factory_context_set_allow_use_intermediate_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_use_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, PROJ_INTERMEDIATE_CRS_USE use)
     * }
     */
    public static void proj_operation_factory_context_set_allow_use_intermediate_crs(MemorySegment ctx, MemorySegment factory_ctx, int use) {
        var mh$ = proj_operation_factory_context_set_allow_use_intermediate_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_allow_use_intermediate_crs", ctx, factory_ctx, use);
            }
            mh$.invokeExact(ctx, factory_ctx, use);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_allowed_intermediate_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_set_allowed_intermediate_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allowed_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *const *list_of_auth_name_codes)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_allowed_intermediate_crs$descriptor() {
        return proj_operation_factory_context_set_allowed_intermediate_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allowed_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *const *list_of_auth_name_codes)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_allowed_intermediate_crs$handle() {
        return proj_operation_factory_context_set_allowed_intermediate_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allowed_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *const *list_of_auth_name_codes)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_allowed_intermediate_crs$address() {
        return proj_operation_factory_context_set_allowed_intermediate_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allowed_intermediate_crs(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, const char *const *list_of_auth_name_codes)
     * }
     */
    public static void proj_operation_factory_context_set_allowed_intermediate_crs(MemorySegment ctx, MemorySegment factory_ctx, MemorySegment list_of_auth_name_codes) {
        var mh$ = proj_operation_factory_context_set_allowed_intermediate_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_allowed_intermediate_crs", ctx, factory_ctx, list_of_auth_name_codes);
            }
            mh$.invokeExact(ctx, factory_ctx, list_of_auth_name_codes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_discard_superseded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_set_discard_superseded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_discard_superseded(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int discard)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_discard_superseded$descriptor() {
        return proj_operation_factory_context_set_discard_superseded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_discard_superseded(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int discard)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_discard_superseded$handle() {
        return proj_operation_factory_context_set_discard_superseded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_discard_superseded(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int discard)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_discard_superseded$address() {
        return proj_operation_factory_context_set_discard_superseded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_discard_superseded(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int discard)
     * }
     */
    public static void proj_operation_factory_context_set_discard_superseded(MemorySegment ctx, MemorySegment factory_ctx, int discard) {
        var mh$ = proj_operation_factory_context_set_discard_superseded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_discard_superseded", ctx, factory_ctx, discard);
            }
            mh$.invokeExact(ctx, factory_ctx, discard);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_operation_factory_context_set_allow_ballpark_transformations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_operation_factory_context_set_allow_ballpark_transformations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_ballpark_transformations(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int allow)
     * }
     */
    public static FunctionDescriptor proj_operation_factory_context_set_allow_ballpark_transformations$descriptor() {
        return proj_operation_factory_context_set_allow_ballpark_transformations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_ballpark_transformations(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int allow)
     * }
     */
    public static MethodHandle proj_operation_factory_context_set_allow_ballpark_transformations$handle() {
        return proj_operation_factory_context_set_allow_ballpark_transformations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_ballpark_transformations(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int allow)
     * }
     */
    public static MemorySegment proj_operation_factory_context_set_allow_ballpark_transformations$address() {
        return proj_operation_factory_context_set_allow_ballpark_transformations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_operation_factory_context_set_allow_ballpark_transformations(PJ_CONTEXT *ctx, PJ_OPERATION_FACTORY_CONTEXT *factory_ctx, int allow)
     * }
     */
    public static void proj_operation_factory_context_set_allow_ballpark_transformations(MemorySegment ctx, MemorySegment factory_ctx, int allow) {
        var mh$ = proj_operation_factory_context_set_allow_ballpark_transformations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_operation_factory_context_set_allow_ballpark_transformations", ctx, factory_ctx, allow);
            }
            mh$.invokeExact(ctx, factory_ctx, allow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_create_operations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_create_operations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_operations(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, const PJ_OPERATION_FACTORY_CONTEXT *operationContext)
     * }
     */
    public static FunctionDescriptor proj_create_operations$descriptor() {
        return proj_create_operations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_operations(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, const PJ_OPERATION_FACTORY_CONTEXT *operationContext)
     * }
     */
    public static MethodHandle proj_create_operations$handle() {
        return proj_create_operations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_operations(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, const PJ_OPERATION_FACTORY_CONTEXT *operationContext)
     * }
     */
    public static MemorySegment proj_create_operations$address() {
        return proj_create_operations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_OBJ_LIST *proj_create_operations(PJ_CONTEXT *ctx, const PJ *source_crs, const PJ *target_crs, const PJ_OPERATION_FACTORY_CONTEXT *operationContext)
     * }
     */
    public static MemorySegment proj_create_operations(MemorySegment ctx, MemorySegment source_crs, MemorySegment target_crs, MemorySegment operationContext) {
        var mh$ = proj_create_operations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_create_operations", ctx, source_crs, target_crs, operationContext);
            }
            return (MemorySegment)mh$.invokeExact(ctx, source_crs, target_crs, operationContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_get_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_list_get_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_list_get_count(const PJ_OBJ_LIST *result)
     * }
     */
    public static FunctionDescriptor proj_list_get_count$descriptor() {
        return proj_list_get_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_list_get_count(const PJ_OBJ_LIST *result)
     * }
     */
    public static MethodHandle proj_list_get_count$handle() {
        return proj_list_get_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_list_get_count(const PJ_OBJ_LIST *result)
     * }
     */
    public static MemorySegment proj_list_get_count$address() {
        return proj_list_get_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_list_get_count(const PJ_OBJ_LIST *result)
     * }
     */
    public static int proj_list_get_count(MemorySegment result) {
        var mh$ = proj_list_get_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_get_count", result);
            }
            return (int)mh$.invokeExact(result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_list_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_list_get(PJ_CONTEXT *ctx, const PJ_OBJ_LIST *result, int index)
     * }
     */
    public static FunctionDescriptor proj_list_get$descriptor() {
        return proj_list_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_list_get(PJ_CONTEXT *ctx, const PJ_OBJ_LIST *result, int index)
     * }
     */
    public static MethodHandle proj_list_get$handle() {
        return proj_list_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_list_get(PJ_CONTEXT *ctx, const PJ_OBJ_LIST *result, int index)
     * }
     */
    public static MemorySegment proj_list_get$address() {
        return proj_list_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_list_get(PJ_CONTEXT *ctx, const PJ_OBJ_LIST *result, int index)
     * }
     */
    public static MemorySegment proj_list_get(MemorySegment ctx, MemorySegment result, int index) {
        var mh$ = proj_list_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_get", ctx, result, index);
            }
            return (MemorySegment)mh$.invokeExact(ctx, result, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_list_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_list_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void proj_list_destroy(PJ_OBJ_LIST *result)
     * }
     */
    public static FunctionDescriptor proj_list_destroy$descriptor() {
        return proj_list_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void proj_list_destroy(PJ_OBJ_LIST *result)
     * }
     */
    public static MethodHandle proj_list_destroy$handle() {
        return proj_list_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void proj_list_destroy(PJ_OBJ_LIST *result)
     * }
     */
    public static MemorySegment proj_list_destroy$address() {
        return proj_list_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void proj_list_destroy(PJ_OBJ_LIST *result)
     * }
     */
    public static void proj_list_destroy(MemorySegment result) {
        var mh$ = proj_list_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_list_destroy", result);
            }
            mh$.invokeExact(result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_suggested_operation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            PJ_COORD.layout()
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_suggested_operation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_get_suggested_operation(PJ_CONTEXT *ctx, PJ_OBJ_LIST *operations, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static FunctionDescriptor proj_get_suggested_operation$descriptor() {
        return proj_get_suggested_operation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_get_suggested_operation(PJ_CONTEXT *ctx, PJ_OBJ_LIST *operations, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static MethodHandle proj_get_suggested_operation$handle() {
        return proj_get_suggested_operation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_get_suggested_operation(PJ_CONTEXT *ctx, PJ_OBJ_LIST *operations, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static MemorySegment proj_get_suggested_operation$address() {
        return proj_get_suggested_operation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_get_suggested_operation(PJ_CONTEXT *ctx, PJ_OBJ_LIST *operations, PJ_DIRECTION direction, PJ_COORD coord)
     * }
     */
    public static int proj_get_suggested_operation(MemorySegment ctx, MemorySegment operations, int direction, MemorySegment coord) {
        var mh$ = proj_get_suggested_operation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_suggested_operation", ctx, operations, direction, coord);
            }
            return (int)mh$.invokeExact(ctx, operations, direction, coord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_is_derived {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_crs_is_derived");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_crs_is_derived(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_is_derived$descriptor() {
        return proj_crs_is_derived.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_crs_is_derived(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_is_derived$handle() {
        return proj_crs_is_derived.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_crs_is_derived(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_is_derived$address() {
        return proj_crs_is_derived.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_crs_is_derived(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static int proj_crs_is_derived(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_is_derived.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_is_derived", ctx, crs);
            }
            return (int)mh$.invokeExact(ctx, crs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_geodetic_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_crs_get_geodetic_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_geodetic_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_geodetic_crs$descriptor() {
        return proj_crs_get_geodetic_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_geodetic_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_geodetic_crs$handle() {
        return proj_crs_get_geodetic_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_geodetic_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_geodetic_crs$address() {
        return proj_crs_get_geodetic_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_geodetic_crs(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_geodetic_crs(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_geodetic_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_geodetic_crs", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_horizontal_datum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_crs_get_horizontal_datum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_horizontal_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_horizontal_datum$descriptor() {
        return proj_crs_get_horizontal_datum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_horizontal_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_horizontal_datum$handle() {
        return proj_crs_get_horizontal_datum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_horizontal_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_horizontal_datum$address() {
        return proj_crs_get_horizontal_datum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_horizontal_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_horizontal_datum(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_horizontal_datum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_horizontal_datum", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_sub_crs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_crs_get_sub_crs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_sub_crs(PJ_CONTEXT *ctx, const PJ *crs, int index)
     * }
     */
    public static FunctionDescriptor proj_crs_get_sub_crs$descriptor() {
        return proj_crs_get_sub_crs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_sub_crs(PJ_CONTEXT *ctx, const PJ *crs, int index)
     * }
     */
    public static MethodHandle proj_crs_get_sub_crs$handle() {
        return proj_crs_get_sub_crs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_sub_crs(PJ_CONTEXT *ctx, const PJ *crs, int index)
     * }
     */
    public static MemorySegment proj_crs_get_sub_crs$address() {
        return proj_crs_get_sub_crs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_sub_crs(PJ_CONTEXT *ctx, const PJ *crs, int index)
     * }
     */
    public static MemorySegment proj_crs_get_sub_crs(MemorySegment ctx, MemorySegment crs, int index) {
        var mh$ = proj_crs_get_sub_crs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_sub_crs", ctx, crs, index);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_datum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_crs_get_datum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_datum$descriptor() {
        return proj_crs_get_datum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_datum$handle() {
        return proj_crs_get_datum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum$address() {
        return proj_crs_get_datum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_datum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_datum", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_datum_ensemble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_crs_get_datum_ensemble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_ensemble(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_datum_ensemble$descriptor() {
        return proj_crs_get_datum_ensemble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_ensemble(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_datum_ensemble$handle() {
        return proj_crs_get_datum_ensemble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_ensemble(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum_ensemble$address() {
        return proj_crs_get_datum_ensemble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_ensemble(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum_ensemble(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_datum_ensemble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_datum_ensemble", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_datum_forced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_crs_get_datum_forced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_forced(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_datum_forced$descriptor() {
        return proj_crs_get_datum_forced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_forced(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_datum_forced$handle() {
        return proj_crs_get_datum_forced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_forced(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum_forced$address() {
        return proj_crs_get_datum_forced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_datum_forced(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_datum_forced(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_datum_forced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_datum_forced", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_datum_ensemble_get_member_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_datum_ensemble_get_member_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_datum_ensemble_get_member_count(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static FunctionDescriptor proj_datum_ensemble_get_member_count$descriptor() {
        return proj_datum_ensemble_get_member_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_datum_ensemble_get_member_count(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static MethodHandle proj_datum_ensemble_get_member_count$handle() {
        return proj_datum_ensemble_get_member_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_datum_ensemble_get_member_count(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static MemorySegment proj_datum_ensemble_get_member_count$address() {
        return proj_datum_ensemble_get_member_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_datum_ensemble_get_member_count(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static int proj_datum_ensemble_get_member_count(MemorySegment ctx, MemorySegment datum_ensemble) {
        var mh$ = proj_datum_ensemble_get_member_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_datum_ensemble_get_member_count", ctx, datum_ensemble);
            }
            return (int)mh$.invokeExact(ctx, datum_ensemble);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_datum_ensemble_get_accuracy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_datum_ensemble_get_accuracy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_datum_ensemble_get_accuracy(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static FunctionDescriptor proj_datum_ensemble_get_accuracy$descriptor() {
        return proj_datum_ensemble_get_accuracy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_datum_ensemble_get_accuracy(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static MethodHandle proj_datum_ensemble_get_accuracy$handle() {
        return proj_datum_ensemble_get_accuracy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_datum_ensemble_get_accuracy(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static MemorySegment proj_datum_ensemble_get_accuracy$address() {
        return proj_datum_ensemble_get_accuracy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_datum_ensemble_get_accuracy(PJ_CONTEXT *ctx, const PJ *datum_ensemble)
     * }
     */
    public static double proj_datum_ensemble_get_accuracy(MemorySegment ctx, MemorySegment datum_ensemble) {
        var mh$ = proj_datum_ensemble_get_accuracy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_datum_ensemble_get_accuracy", ctx, datum_ensemble);
            }
            return (double)mh$.invokeExact(ctx, datum_ensemble);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_datum_ensemble_get_member {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_datum_ensemble_get_member");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_datum_ensemble_get_member(PJ_CONTEXT *ctx, const PJ *datum_ensemble, int member_index)
     * }
     */
    public static FunctionDescriptor proj_datum_ensemble_get_member$descriptor() {
        return proj_datum_ensemble_get_member.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_datum_ensemble_get_member(PJ_CONTEXT *ctx, const PJ *datum_ensemble, int member_index)
     * }
     */
    public static MethodHandle proj_datum_ensemble_get_member$handle() {
        return proj_datum_ensemble_get_member.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_datum_ensemble_get_member(PJ_CONTEXT *ctx, const PJ *datum_ensemble, int member_index)
     * }
     */
    public static MemorySegment proj_datum_ensemble_get_member$address() {
        return proj_datum_ensemble_get_member.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_datum_ensemble_get_member(PJ_CONTEXT *ctx, const PJ *datum_ensemble, int member_index)
     * }
     */
    public static MemorySegment proj_datum_ensemble_get_member(MemorySegment ctx, MemorySegment datum_ensemble, int member_index) {
        var mh$ = proj_datum_ensemble_get_member.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_datum_ensemble_get_member", ctx, datum_ensemble, member_index);
            }
            return (MemorySegment)mh$.invokeExact(ctx, datum_ensemble, member_index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_dynamic_datum_get_frame_reference_epoch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_dynamic_datum_get_frame_reference_epoch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_dynamic_datum_get_frame_reference_epoch(PJ_CONTEXT *ctx, const PJ *datum)
     * }
     */
    public static FunctionDescriptor proj_dynamic_datum_get_frame_reference_epoch$descriptor() {
        return proj_dynamic_datum_get_frame_reference_epoch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_dynamic_datum_get_frame_reference_epoch(PJ_CONTEXT *ctx, const PJ *datum)
     * }
     */
    public static MethodHandle proj_dynamic_datum_get_frame_reference_epoch$handle() {
        return proj_dynamic_datum_get_frame_reference_epoch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_dynamic_datum_get_frame_reference_epoch(PJ_CONTEXT *ctx, const PJ *datum)
     * }
     */
    public static MemorySegment proj_dynamic_datum_get_frame_reference_epoch$address() {
        return proj_dynamic_datum_get_frame_reference_epoch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_dynamic_datum_get_frame_reference_epoch(PJ_CONTEXT *ctx, const PJ *datum)
     * }
     */
    public static double proj_dynamic_datum_get_frame_reference_epoch(MemorySegment ctx, MemorySegment datum) {
        var mh$ = proj_dynamic_datum_get_frame_reference_epoch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_dynamic_datum_get_frame_reference_epoch", ctx, datum);
            }
            return (double)mh$.invokeExact(ctx, datum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_coordinate_system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_crs_get_coordinate_system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordinate_system(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_coordinate_system$descriptor() {
        return proj_crs_get_coordinate_system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordinate_system(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_coordinate_system$handle() {
        return proj_crs_get_coordinate_system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordinate_system(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_coordinate_system$address() {
        return proj_crs_get_coordinate_system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordinate_system(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_coordinate_system(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_coordinate_system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_coordinate_system", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_cs_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_cs_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ_COORDINATE_SYSTEM_TYPE proj_cs_get_type(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static FunctionDescriptor proj_cs_get_type$descriptor() {
        return proj_cs_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ_COORDINATE_SYSTEM_TYPE proj_cs_get_type(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static MethodHandle proj_cs_get_type$handle() {
        return proj_cs_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ_COORDINATE_SYSTEM_TYPE proj_cs_get_type(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static MemorySegment proj_cs_get_type$address() {
        return proj_cs_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ_COORDINATE_SYSTEM_TYPE proj_cs_get_type(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static int proj_cs_get_type(MemorySegment ctx, MemorySegment cs) {
        var mh$ = proj_cs_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_cs_get_type", ctx, cs);
            }
            return (int)mh$.invokeExact(ctx, cs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_cs_get_axis_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_cs_get_axis_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_count(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static FunctionDescriptor proj_cs_get_axis_count$descriptor() {
        return proj_cs_get_axis_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_count(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static MethodHandle proj_cs_get_axis_count$handle() {
        return proj_cs_get_axis_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_count(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static MemorySegment proj_cs_get_axis_count$address() {
        return proj_cs_get_axis_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_cs_get_axis_count(PJ_CONTEXT *ctx, const PJ *cs)
     * }
     */
    public static int proj_cs_get_axis_count(MemorySegment ctx, MemorySegment cs) {
        var mh$ = proj_cs_get_axis_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_cs_get_axis_count", ctx, cs);
            }
            return (int)mh$.invokeExact(ctx, cs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_cs_get_axis_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_cs_get_axis_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_info(PJ_CONTEXT *ctx, const PJ *cs, int index, const char **out_name, const char **out_abbrev, const char **out_direction, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code)
     * }
     */
    public static FunctionDescriptor proj_cs_get_axis_info$descriptor() {
        return proj_cs_get_axis_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_info(PJ_CONTEXT *ctx, const PJ *cs, int index, const char **out_name, const char **out_abbrev, const char **out_direction, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code)
     * }
     */
    public static MethodHandle proj_cs_get_axis_info$handle() {
        return proj_cs_get_axis_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_cs_get_axis_info(PJ_CONTEXT *ctx, const PJ *cs, int index, const char **out_name, const char **out_abbrev, const char **out_direction, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code)
     * }
     */
    public static MemorySegment proj_cs_get_axis_info$address() {
        return proj_cs_get_axis_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_cs_get_axis_info(PJ_CONTEXT *ctx, const PJ *cs, int index, const char **out_name, const char **out_abbrev, const char **out_direction, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code)
     * }
     */
    public static int proj_cs_get_axis_info(MemorySegment ctx, MemorySegment cs, int index, MemorySegment out_name, MemorySegment out_abbrev, MemorySegment out_direction, MemorySegment out_unit_conv_factor, MemorySegment out_unit_name, MemorySegment out_unit_auth_name, MemorySegment out_unit_code) {
        var mh$ = proj_cs_get_axis_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_cs_get_axis_info", ctx, cs, index, out_name, out_abbrev, out_direction, out_unit_conv_factor, out_unit_name, out_unit_auth_name, out_unit_code);
            }
            return (int)mh$.invokeExact(ctx, cs, index, out_name, out_abbrev, out_direction, out_unit_conv_factor, out_unit_name, out_unit_auth_name, out_unit_code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_ellipsoid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_ellipsoid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_get_ellipsoid(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_ellipsoid$descriptor() {
        return proj_get_ellipsoid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_get_ellipsoid(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_ellipsoid$handle() {
        return proj_get_ellipsoid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_get_ellipsoid(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_ellipsoid$address() {
        return proj_get_ellipsoid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_get_ellipsoid(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_ellipsoid(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_ellipsoid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_ellipsoid", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_ellipsoid_get_parameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_ellipsoid_get_parameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_ellipsoid_get_parameters(PJ_CONTEXT *ctx, const PJ *ellipsoid, double *out_semi_major_metre, double *out_semi_minor_metre, int *out_is_semi_minor_computed, double *out_inv_flattening)
     * }
     */
    public static FunctionDescriptor proj_ellipsoid_get_parameters$descriptor() {
        return proj_ellipsoid_get_parameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_ellipsoid_get_parameters(PJ_CONTEXT *ctx, const PJ *ellipsoid, double *out_semi_major_metre, double *out_semi_minor_metre, int *out_is_semi_minor_computed, double *out_inv_flattening)
     * }
     */
    public static MethodHandle proj_ellipsoid_get_parameters$handle() {
        return proj_ellipsoid_get_parameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_ellipsoid_get_parameters(PJ_CONTEXT *ctx, const PJ *ellipsoid, double *out_semi_major_metre, double *out_semi_minor_metre, int *out_is_semi_minor_computed, double *out_inv_flattening)
     * }
     */
    public static MemorySegment proj_ellipsoid_get_parameters$address() {
        return proj_ellipsoid_get_parameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_ellipsoid_get_parameters(PJ_CONTEXT *ctx, const PJ *ellipsoid, double *out_semi_major_metre, double *out_semi_minor_metre, int *out_is_semi_minor_computed, double *out_inv_flattening)
     * }
     */
    public static int proj_ellipsoid_get_parameters(MemorySegment ctx, MemorySegment ellipsoid, MemorySegment out_semi_major_metre, MemorySegment out_semi_minor_metre, MemorySegment out_is_semi_minor_computed, MemorySegment out_inv_flattening) {
        var mh$ = proj_ellipsoid_get_parameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_ellipsoid_get_parameters", ctx, ellipsoid, out_semi_major_metre, out_semi_minor_metre, out_is_semi_minor_computed, out_inv_flattening);
            }
            return (int)mh$.invokeExact(ctx, ellipsoid, out_semi_major_metre, out_semi_minor_metre, out_is_semi_minor_computed, out_inv_flattening);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_celestial_body_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_celestial_body_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *proj_get_celestial_body_name(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_celestial_body_name$descriptor() {
        return proj_get_celestial_body_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *proj_get_celestial_body_name(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_celestial_body_name$handle() {
        return proj_get_celestial_body_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *proj_get_celestial_body_name(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_celestial_body_name$address() {
        return proj_get_celestial_body_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *proj_get_celestial_body_name(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_celestial_body_name(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_celestial_body_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_celestial_body_name", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_get_prime_meridian {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_get_prime_meridian");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_get_prime_meridian(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_get_prime_meridian$descriptor() {
        return proj_get_prime_meridian.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_get_prime_meridian(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_get_prime_meridian$handle() {
        return proj_get_prime_meridian.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_get_prime_meridian(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_prime_meridian$address() {
        return proj_get_prime_meridian.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_get_prime_meridian(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_get_prime_meridian(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_get_prime_meridian.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_get_prime_meridian", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_prime_meridian_get_parameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_prime_meridian_get_parameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_prime_meridian_get_parameters(PJ_CONTEXT *ctx, const PJ *prime_meridian, double *out_longitude, double *out_unit_conv_factor, const char **out_unit_name)
     * }
     */
    public static FunctionDescriptor proj_prime_meridian_get_parameters$descriptor() {
        return proj_prime_meridian_get_parameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_prime_meridian_get_parameters(PJ_CONTEXT *ctx, const PJ *prime_meridian, double *out_longitude, double *out_unit_conv_factor, const char **out_unit_name)
     * }
     */
    public static MethodHandle proj_prime_meridian_get_parameters$handle() {
        return proj_prime_meridian_get_parameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_prime_meridian_get_parameters(PJ_CONTEXT *ctx, const PJ *prime_meridian, double *out_longitude, double *out_unit_conv_factor, const char **out_unit_name)
     * }
     */
    public static MemorySegment proj_prime_meridian_get_parameters$address() {
        return proj_prime_meridian_get_parameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_prime_meridian_get_parameters(PJ_CONTEXT *ctx, const PJ *prime_meridian, double *out_longitude, double *out_unit_conv_factor, const char **out_unit_name)
     * }
     */
    public static int proj_prime_meridian_get_parameters(MemorySegment ctx, MemorySegment prime_meridian, MemorySegment out_longitude, MemorySegment out_unit_conv_factor, MemorySegment out_unit_name) {
        var mh$ = proj_prime_meridian_get_parameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_prime_meridian_get_parameters", ctx, prime_meridian, out_longitude, out_unit_conv_factor, out_unit_name);
            }
            return (int)mh$.invokeExact(ctx, prime_meridian, out_longitude, out_unit_conv_factor, out_unit_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_crs_get_coordoperation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_crs_get_coordoperation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordoperation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static FunctionDescriptor proj_crs_get_coordoperation$descriptor() {
        return proj_crs_get_coordoperation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordoperation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MethodHandle proj_crs_get_coordoperation$handle() {
        return proj_crs_get_coordoperation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordoperation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_coordoperation$address() {
        return proj_crs_get_coordoperation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_crs_get_coordoperation(PJ_CONTEXT *ctx, const PJ *crs)
     * }
     */
    public static MemorySegment proj_crs_get_coordoperation(MemorySegment ctx, MemorySegment crs) {
        var mh$ = proj_crs_get_coordoperation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_crs_get_coordoperation", ctx, crs);
            }
            return (MemorySegment)mh$.invokeExact(ctx, crs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_method_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_get_method_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_method_info(PJ_CONTEXT *ctx, const PJ *coordoperation, const char **out_method_name, const char **out_method_auth_name, const char **out_method_code)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_method_info$descriptor() {
        return proj_coordoperation_get_method_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_method_info(PJ_CONTEXT *ctx, const PJ *coordoperation, const char **out_method_name, const char **out_method_auth_name, const char **out_method_code)
     * }
     */
    public static MethodHandle proj_coordoperation_get_method_info$handle() {
        return proj_coordoperation_get_method_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_method_info(PJ_CONTEXT *ctx, const PJ *coordoperation, const char **out_method_name, const char **out_method_auth_name, const char **out_method_code)
     * }
     */
    public static MemorySegment proj_coordoperation_get_method_info$address() {
        return proj_coordoperation_get_method_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_method_info(PJ_CONTEXT *ctx, const PJ *coordoperation, const char **out_method_name, const char **out_method_auth_name, const char **out_method_code)
     * }
     */
    public static int proj_coordoperation_get_method_info(MemorySegment ctx, MemorySegment coordoperation, MemorySegment out_method_name, MemorySegment out_method_auth_name, MemorySegment out_method_code) {
        var mh$ = proj_coordoperation_get_method_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_method_info", ctx, coordoperation, out_method_name, out_method_auth_name, out_method_code);
            }
            return (int)mh$.invokeExact(ctx, coordoperation, out_method_name, out_method_auth_name, out_method_code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_is_instantiable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_is_instantiable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_is_instantiable(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_is_instantiable$descriptor() {
        return proj_coordoperation_is_instantiable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_is_instantiable(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MethodHandle proj_coordoperation_is_instantiable$handle() {
        return proj_coordoperation_is_instantiable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_is_instantiable(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MemorySegment proj_coordoperation_is_instantiable$address() {
        return proj_coordoperation_is_instantiable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_is_instantiable(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static int proj_coordoperation_is_instantiable(MemorySegment ctx, MemorySegment coordoperation) {
        var mh$ = proj_coordoperation_is_instantiable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_is_instantiable", ctx, coordoperation);
            }
            return (int)mh$.invokeExact(ctx, coordoperation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_has_ballpark_transformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_has_ballpark_transformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_has_ballpark_transformation(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_has_ballpark_transformation$descriptor() {
        return proj_coordoperation_has_ballpark_transformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_has_ballpark_transformation(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MethodHandle proj_coordoperation_has_ballpark_transformation$handle() {
        return proj_coordoperation_has_ballpark_transformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_has_ballpark_transformation(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MemorySegment proj_coordoperation_has_ballpark_transformation$address() {
        return proj_coordoperation_has_ballpark_transformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_has_ballpark_transformation(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static int proj_coordoperation_has_ballpark_transformation(MemorySegment ctx, MemorySegment coordoperation) {
        var mh$ = proj_coordoperation_has_ballpark_transformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_has_ballpark_transformation", ctx, coordoperation);
            }
            return (int)mh$.invokeExact(ctx, coordoperation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_param_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_get_param_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_param_count$descriptor() {
        return proj_coordoperation_get_param_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MethodHandle proj_coordoperation_get_param_count$handle() {
        return proj_coordoperation_get_param_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MemorySegment proj_coordoperation_get_param_count$address() {
        return proj_coordoperation_get_param_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static int proj_coordoperation_get_param_count(MemorySegment ctx, MemorySegment coordoperation) {
        var mh$ = proj_coordoperation_get_param_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_param_count", ctx, coordoperation);
            }
            return (int)mh$.invokeExact(ctx, coordoperation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_param_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_get_param_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_index(PJ_CONTEXT *ctx, const PJ *coordoperation, const char *name)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_param_index$descriptor() {
        return proj_coordoperation_get_param_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_index(PJ_CONTEXT *ctx, const PJ *coordoperation, const char *name)
     * }
     */
    public static MethodHandle proj_coordoperation_get_param_index$handle() {
        return proj_coordoperation_get_param_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_index(PJ_CONTEXT *ctx, const PJ *coordoperation, const char *name)
     * }
     */
    public static MemorySegment proj_coordoperation_get_param_index$address() {
        return proj_coordoperation_get_param_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_param_index(PJ_CONTEXT *ctx, const PJ *coordoperation, const char *name)
     * }
     */
    public static int proj_coordoperation_get_param_index(MemorySegment ctx, MemorySegment coordoperation, MemorySegment name) {
        var mh$ = proj_coordoperation_get_param_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_param_index", ctx, coordoperation, name);
            }
            return (int)mh$.invokeExact(ctx, coordoperation, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_param {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_get_param");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_name, const char **out_auth_name, const char **out_code, double *out_value, const char **out_value_string, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code, const char **out_unit_category)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_param$descriptor() {
        return proj_coordoperation_get_param.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_name, const char **out_auth_name, const char **out_code, double *out_value, const char **out_value_string, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code, const char **out_unit_category)
     * }
     */
    public static MethodHandle proj_coordoperation_get_param$handle() {
        return proj_coordoperation_get_param.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_param(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_name, const char **out_auth_name, const char **out_code, double *out_value, const char **out_value_string, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code, const char **out_unit_category)
     * }
     */
    public static MemorySegment proj_coordoperation_get_param$address() {
        return proj_coordoperation_get_param.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_param(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_name, const char **out_auth_name, const char **out_code, double *out_value, const char **out_value_string, double *out_unit_conv_factor, const char **out_unit_name, const char **out_unit_auth_name, const char **out_unit_code, const char **out_unit_category)
     * }
     */
    public static int proj_coordoperation_get_param(MemorySegment ctx, MemorySegment coordoperation, int index, MemorySegment out_name, MemorySegment out_auth_name, MemorySegment out_code, MemorySegment out_value, MemorySegment out_value_string, MemorySegment out_unit_conv_factor, MemorySegment out_unit_name, MemorySegment out_unit_auth_name, MemorySegment out_unit_code, MemorySegment out_unit_category) {
        var mh$ = proj_coordoperation_get_param.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_param", ctx, coordoperation, index, out_name, out_auth_name, out_code, out_value, out_value_string, out_unit_conv_factor, out_unit_name, out_unit_auth_name, out_unit_code, out_unit_category);
            }
            return (int)mh$.invokeExact(ctx, coordoperation, index, out_name, out_auth_name, out_code, out_value, out_value_string, out_unit_conv_factor, out_unit_name, out_unit_auth_name, out_unit_code, out_unit_category);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_grid_used_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_get_grid_used_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_grid_used_count$descriptor() {
        return proj_coordoperation_get_grid_used_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MethodHandle proj_coordoperation_get_grid_used_count$handle() {
        return proj_coordoperation_get_grid_used_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static MemorySegment proj_coordoperation_get_grid_used_count$address() {
        return proj_coordoperation_get_grid_used_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used_count(PJ_CONTEXT *ctx, const PJ *coordoperation)
     * }
     */
    public static int proj_coordoperation_get_grid_used_count(MemorySegment ctx, MemorySegment coordoperation) {
        var mh$ = proj_coordoperation_get_grid_used_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_grid_used_count", ctx, coordoperation);
            }
            return (int)mh$.invokeExact(ctx, coordoperation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_grid_used {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_get_grid_used");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_short_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_grid_used$descriptor() {
        return proj_coordoperation_get_grid_used.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_short_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static MethodHandle proj_coordoperation_get_grid_used$handle() {
        return proj_coordoperation_get_grid_used.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_short_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static MemorySegment proj_coordoperation_get_grid_used$address() {
        return proj_coordoperation_get_grid_used.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_grid_used(PJ_CONTEXT *ctx, const PJ *coordoperation, int index, const char **out_short_name, const char **out_full_name, const char **out_package_name, const char **out_url, int *out_direct_download, int *out_open_license, int *out_available)
     * }
     */
    public static int proj_coordoperation_get_grid_used(MemorySegment ctx, MemorySegment coordoperation, int index, MemorySegment out_short_name, MemorySegment out_full_name, MemorySegment out_package_name, MemorySegment out_url, MemorySegment out_direct_download, MemorySegment out_open_license, MemorySegment out_available) {
        var mh$ = proj_coordoperation_get_grid_used.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_grid_used", ctx, coordoperation, index, out_short_name, out_full_name, out_package_name, out_url, out_direct_download, out_open_license, out_available);
            }
            return (int)mh$.invokeExact(ctx, coordoperation, index, out_short_name, out_full_name, out_package_name, out_url, out_direct_download, out_open_license, out_available);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_accuracy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_DOUBLE,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_get_accuracy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double proj_coordoperation_get_accuracy(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_accuracy$descriptor() {
        return proj_coordoperation_get_accuracy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double proj_coordoperation_get_accuracy(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_coordoperation_get_accuracy$handle() {
        return proj_coordoperation_get_accuracy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double proj_coordoperation_get_accuracy(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_coordoperation_get_accuracy$address() {
        return proj_coordoperation_get_accuracy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double proj_coordoperation_get_accuracy(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static double proj_coordoperation_get_accuracy(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_coordoperation_get_accuracy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_accuracy", ctx, obj);
            }
            return (double)mh$.invokeExact(ctx, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_get_towgs84_values {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_get_towgs84_values");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_towgs84_values(PJ_CONTEXT *ctx, const PJ *coordoperation, double *out_values, int value_count, int emit_error_if_incompatible)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_get_towgs84_values$descriptor() {
        return proj_coordoperation_get_towgs84_values.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_towgs84_values(PJ_CONTEXT *ctx, const PJ *coordoperation, double *out_values, int value_count, int emit_error_if_incompatible)
     * }
     */
    public static MethodHandle proj_coordoperation_get_towgs84_values$handle() {
        return proj_coordoperation_get_towgs84_values.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_coordoperation_get_towgs84_values(PJ_CONTEXT *ctx, const PJ *coordoperation, double *out_values, int value_count, int emit_error_if_incompatible)
     * }
     */
    public static MemorySegment proj_coordoperation_get_towgs84_values$address() {
        return proj_coordoperation_get_towgs84_values.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_coordoperation_get_towgs84_values(PJ_CONTEXT *ctx, const PJ *coordoperation, double *out_values, int value_count, int emit_error_if_incompatible)
     * }
     */
    public static int proj_coordoperation_get_towgs84_values(MemorySegment ctx, MemorySegment coordoperation, MemorySegment out_values, int value_count, int emit_error_if_incompatible) {
        var mh$ = proj_coordoperation_get_towgs84_values.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_get_towgs84_values", ctx, coordoperation, out_values, value_count, emit_error_if_incompatible);
            }
            return (int)mh$.invokeExact(ctx, coordoperation, out_values, value_count, emit_error_if_incompatible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_coordoperation_create_inverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_coordoperation_create_inverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_coordoperation_create_inverse(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static FunctionDescriptor proj_coordoperation_create_inverse$descriptor() {
        return proj_coordoperation_create_inverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_coordoperation_create_inverse(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MethodHandle proj_coordoperation_create_inverse$handle() {
        return proj_coordoperation_create_inverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_coordoperation_create_inverse(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_coordoperation_create_inverse$address() {
        return proj_coordoperation_create_inverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_coordoperation_create_inverse(PJ_CONTEXT *ctx, const PJ *obj)
     * }
     */
    public static MemorySegment proj_coordoperation_create_inverse(MemorySegment ctx, MemorySegment obj) {
        var mh$ = proj_coordoperation_create_inverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_coordoperation_create_inverse", ctx, obj);
            }
            return (MemorySegment)mh$.invokeExact(ctx, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_concatoperation_get_step_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_INT,
            proj_h.C_POINTER,
            proj_h.C_POINTER
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_concatoperation_get_step_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int proj_concatoperation_get_step_count(PJ_CONTEXT *ctx, const PJ *concatoperation)
     * }
     */
    public static FunctionDescriptor proj_concatoperation_get_step_count$descriptor() {
        return proj_concatoperation_get_step_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int proj_concatoperation_get_step_count(PJ_CONTEXT *ctx, const PJ *concatoperation)
     * }
     */
    public static MethodHandle proj_concatoperation_get_step_count$handle() {
        return proj_concatoperation_get_step_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int proj_concatoperation_get_step_count(PJ_CONTEXT *ctx, const PJ *concatoperation)
     * }
     */
    public static MemorySegment proj_concatoperation_get_step_count$address() {
        return proj_concatoperation_get_step_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int proj_concatoperation_get_step_count(PJ_CONTEXT *ctx, const PJ *concatoperation)
     * }
     */
    public static int proj_concatoperation_get_step_count(MemorySegment ctx, MemorySegment concatoperation) {
        var mh$ = proj_concatoperation_get_step_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_concatoperation_get_step_count", ctx, concatoperation);
            }
            return (int)mh$.invokeExact(ctx, concatoperation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class proj_concatoperation_get_step {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_POINTER,
            proj_h.C_INT
        );

        public static final MemorySegment ADDR = proj_h.findOrThrow("proj_concatoperation_get_step");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PJ *proj_concatoperation_get_step(PJ_CONTEXT *ctx, const PJ *concatoperation, int i_step)
     * }
     */
    public static FunctionDescriptor proj_concatoperation_get_step$descriptor() {
        return proj_concatoperation_get_step.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PJ *proj_concatoperation_get_step(PJ_CONTEXT *ctx, const PJ *concatoperation, int i_step)
     * }
     */
    public static MethodHandle proj_concatoperation_get_step$handle() {
        return proj_concatoperation_get_step.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PJ *proj_concatoperation_get_step(PJ_CONTEXT *ctx, const PJ *concatoperation, int i_step)
     * }
     */
    public static MemorySegment proj_concatoperation_get_step$address() {
        return proj_concatoperation_get_step.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PJ *proj_concatoperation_get_step(PJ_CONTEXT *ctx, const PJ *concatoperation, int i_step)
     * }
     */
    public static MemorySegment proj_concatoperation_get_step(MemorySegment ctx, MemorySegment concatoperation, int i_step) {
        var mh$ = proj_concatoperation_get_step.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("proj_concatoperation_get_step", ctx, concatoperation, i_step);
            }
            return (MemorySegment)mh$.invokeExact(ctx, concatoperation, i_step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int PROJ_VERSION_NUMBER = (int)80201L;
    /**
     * {@snippet lang=c :
     * #define PROJ_VERSION_NUMBER 80201
     * }
     */
    public static int PROJ_VERSION_NUMBER() {
        return PROJ_VERSION_NUMBER;
    }
    private static final int PROJ_ERR_INVALID_OP_WRONG_SYNTAX = (int)1025L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP_WRONG_SYNTAX 1025
     * }
     */
    public static int PROJ_ERR_INVALID_OP_WRONG_SYNTAX() {
        return PROJ_ERR_INVALID_OP_WRONG_SYNTAX;
    }
    private static final int PROJ_ERR_INVALID_OP_MISSING_ARG = (int)1026L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP_MISSING_ARG 1026
     * }
     */
    public static int PROJ_ERR_INVALID_OP_MISSING_ARG() {
        return PROJ_ERR_INVALID_OP_MISSING_ARG;
    }
    private static final int PROJ_ERR_INVALID_OP_ILLEGAL_ARG_VALUE = (int)1027L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP_ILLEGAL_ARG_VALUE 1027
     * }
     */
    public static int PROJ_ERR_INVALID_OP_ILLEGAL_ARG_VALUE() {
        return PROJ_ERR_INVALID_OP_ILLEGAL_ARG_VALUE;
    }
    private static final int PROJ_ERR_INVALID_OP_MUTUALLY_EXCLUSIVE_ARGS = (int)1028L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP_MUTUALLY_EXCLUSIVE_ARGS 1028
     * }
     */
    public static int PROJ_ERR_INVALID_OP_MUTUALLY_EXCLUSIVE_ARGS() {
        return PROJ_ERR_INVALID_OP_MUTUALLY_EXCLUSIVE_ARGS;
    }
    private static final int PROJ_ERR_INVALID_OP_FILE_NOT_FOUND_OR_INVALID = (int)1029L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_INVALID_OP_FILE_NOT_FOUND_OR_INVALID 1029
     * }
     */
    public static int PROJ_ERR_INVALID_OP_FILE_NOT_FOUND_OR_INVALID() {
        return PROJ_ERR_INVALID_OP_FILE_NOT_FOUND_OR_INVALID;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_INVALID_COORD = (int)2049L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_INVALID_COORD 2049
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_INVALID_COORD() {
        return PROJ_ERR_COORD_TRANSFM_INVALID_COORD;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN = (int)2050L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN 2050
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN() {
        return PROJ_ERR_COORD_TRANSFM_OUTSIDE_PROJECTION_DOMAIN;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_NO_OPERATION = (int)2051L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_NO_OPERATION 2051
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_NO_OPERATION() {
        return PROJ_ERR_COORD_TRANSFM_NO_OPERATION;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_OUTSIDE_GRID = (int)2052L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_OUTSIDE_GRID 2052
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_OUTSIDE_GRID() {
        return PROJ_ERR_COORD_TRANSFM_OUTSIDE_GRID;
    }
    private static final int PROJ_ERR_COORD_TRANSFM_GRID_AT_NODATA = (int)2053L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_COORD_TRANSFM_GRID_AT_NODATA 2053
     * }
     */
    public static int PROJ_ERR_COORD_TRANSFM_GRID_AT_NODATA() {
        return PROJ_ERR_COORD_TRANSFM_GRID_AT_NODATA;
    }
    private static final int PROJ_ERR_OTHER_API_MISUSE = (int)4097L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_OTHER_API_MISUSE 4097
     * }
     */
    public static int PROJ_ERR_OTHER_API_MISUSE() {
        return PROJ_ERR_OTHER_API_MISUSE;
    }
    private static final int PROJ_ERR_OTHER_NO_INVERSE_OP = (int)4098L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_OTHER_NO_INVERSE_OP 4098
     * }
     */
    public static int PROJ_ERR_OTHER_NO_INVERSE_OP() {
        return PROJ_ERR_OTHER_NO_INVERSE_OP;
    }
    private static final int PROJ_ERR_OTHER_NETWORK_ERROR = (int)4099L;
    /**
     * {@snippet lang=c :
     * #define PROJ_ERR_OTHER_NETWORK_ERROR 4099
     * }
     */
    public static int PROJ_ERR_OTHER_NETWORK_ERROR() {
        return PROJ_ERR_OTHER_NETWORK_ERROR;
    }
}

